// Given a singly linked list L: L0→L1→…→Ln-1→Ln,
// reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…

// You must do this in-place without altering the nodes' values.

// For example,
// Given {1,2,3,4}, reorder it to {1,4,2,3}.

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

#include <stdio.h>
#include <stdlib.h>

#include "lib/list.h"

typedef struct ListNode* Position;
typedef struct ListNode* List;
typedef struct StackRecord* Stack;

#define ElementType Position
#define MAX 16

struct StackRecord
{
	int Size;
	int Capacity;
	ElementType* Next;
};

Stack Initialize(int Capacity)
{
	Stack S;

	S = malloc(sizeof(struct StackRecord));
	S -> Size = 0;
	S -> Capacity = Capacity;
	S -> Next = malloc(sizeof(ElementType) * Capacity);

	return S;
}

int IsFull(Stack S)
{
	return S -> Size == S -> Capacity;
}

int IsEmpty(Stack S)
{
	return S -> Size == 0;
}

void Push(Stack S, ElementType Value)
{
	if (IsFull(S))
	{
		S -> Next = realloc(S -> Next, sizeof(ElementType) * S -> Capacity * 2);
		S -> Capacity *= 2;
	}

	S -> Next[S -> Size++] = Value;
}

ElementType Pop(Stack S)
{
	if (IsEmpty(S))
	{
		fprintf(stderr, "Empty Stack\n");
		exit(1);
	}

	return S -> Next[--S -> Size];
}

void Destroy(Stack S)
{
	free(S -> Next);
	free(S);
}

void reorderList(struct ListNode* head) {
	if (head == NULL || head -> next == NULL)
		return;

	Position P1, P2, P3;
	Stack S;

	P1 = P2 = head;

	while (P1 != NULL)
	{
		if (P1 -> next == NULL)
			break;

		P1 = P1 -> next -> next;
		P2 = P2 -> next;
	}

	P1 = P2 -> next;
	P2 -> next = NULL;

	S = Initialize(MAX);

	while (P1 != NULL)
	{
		Push(S, P1);
		P1 = P1 -> next;
	}

	P1 = head;

	while (!IsEmpty(S))
	{
		P2 = Pop(S);
		P3 = P1 -> next;
		P1 -> next = P2;
		P2 -> next = P3;
		P1 = P2 -> next;
	}

	return;
}

int main(int argc, char const *argv[])
{
  List L1, L2, L;

	L1 = CreateEvenList(1);
  L2 = CreateOddList(10);
  PrintList(L1);
  PrintList(L2);

  reorderList(L1);
  PrintList(L1);
	return 0;
}// Given n, generate all structurally unique BST's (binary search trees) that store values 1...n.

// For example,
// Given n = 3, your program should return all 5 unique BST's shown below.

//    1         3     3      2      1
//     \       /     /      / \      \
//      3     2     1      1   3      2
//     /     /       \                 \
//    2     1         2                 3


/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
/**
 * Return an array of size *returnSize.
 * Note: The returned array must be malloced, assume caller calls free().
 */

struct TreeNode {
	int val;
	struct TreeNode* left;
	struct TreeNode* right;
};

typedef struct TreeNode* Tree;

Tree NewNode(int value)
{
  Tree T;
  struct TreeNode node;
  T = (Tree)malloc(sizeof(struct TreeNode));
  T -> val = value;
  T -> left = T -> right = NULL;
  return T;
}

Tree CreateTree(int first, int end)
{
	int i;
	Tree T;

	if (first == end)
	{
		return NewNode(first);
	}

	if (first > end)
	{
		return NULL;
	}

	for (i = first; i <= end; ++i)
	{
		T = NewNode(first);
		T -> left = CreateTree(i, first - 1);
		T -> right = CreateTree(first + 1, end);
	}	

	
}

struct TreeNode** generateTrees(int n, int* returnSize) {
    
}// Given n, how many structurally unique BST's (binary search trees) that store values 1...n?

// For example,
// Given n = 3, there are a total of 5 unique BST's.

//    1         3     3      2      1
//     \       /     /      / \      \
//      3     2     1      1   3      2
//     /     /       \                 \
//    2     1         2                 3

#include <stdio.h>
#include <stdlib.h>

int GetNumberTrees(int* Numbers, int n)
{
	if (Numbers[n] != -1)
		return Numbers[n];

	Numbers[n] = numTrees(n);
	return Numbers[n];
}

int numTrees(int n) {
 if (n == 0)
 	return 1;

 if (n == 1)
 	return 1;

 int i, Sum;
 int* Nums;

 Nums = malloc(sizeof(int) * n);
 for (i = 0; i < n; ++i)
 	Nums[i] = -1;

 Sum = 0;
 for (i = 0; i < n / 2; ++i)
 	Sum += GetNumberTrees(Nums, i) * GetNumberTrees(Nums, n - i - 1);

 Sum *= 2;
 if (n % 2 == 1)
 	Sum += GetNumberTrees(Nums, n / 2) * GetNumberTrees(Nums, n / 2);

 free(Nums);
 return Sum;
}

int main(int argc, char const *argv[])
{
	int n, i;

	n = 19;

	for (i = 0; i <= n; ++i)
		printf("%d: %d\n", i, numTrees(i));
	return 0;
}/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

#include <stdio.h>
#include <stdlib.h>

#include "lib/tree.h"

typedef struct TreeNode* Tree;
typedef struct TreeNode* Position;

#define ElementType Position
#define SIZE 2

struct StackRecord
{
  int Size;
  int Capacity;
  ElementType* Next;
};

typedef struct StackRecord* Stack;
#define SIZE 2

Stack Initialize()
{
  Stack S;

  S = malloc(sizeof(struct StackRecord));
  S -> Size = 0;
  S -> Capacity = SIZE;
  S -> Next = malloc(sizeof(ElementType) * S -> Capacity);

  return S;
}

int IsEmpty(Stack S)
{
  return S -> Size == 0;
}

int IsFull(Stack S)
{
  return S -> Capacity == S -> Size;
}

ElementType Pop(Stack S)
{
  if (IsEmpty(S))
  {
    fprintf(stderr, "Empty Stack\n");
    exit(1);
  }

  return S -> Next[--S -> Size];
}

void Push(Stack S, ElementType X)
{
  if (IsFull(S))
  {
    S -> Next = realloc(S -> Next, sizeof(ElementType) * S -> Capacity * 2);
    S -> Capacity *= 2;
  }

  S -> Next[S -> Size++] = X;
}

void Destroy(Stack S)
{
  free(S -> Next);
  free(S);
}

int GetPathToNode(Stack S, Tree Root, Position Node)
{
	if (Root == NULL)
		return 0;

	int LeftFound, RightFound;

	Push(S, Root);
	if (Node == Root)
		return 1;

	LeftFound = GetPathToNode(S, Root -> left, Node);
	if (LeftFound == 0)
		RightFound = GetPathToNode(S, Root -> right, Node);

	if (LeftFound || RightFound)
		return 1;

	Pop(S);
	return 0;
}

Position GetMaxCommonNode(Stack S1, Stack S2)
{
	int i;

	i = 0;
	while (!IsEmpty(S1) && !IsEmpty(S2))
	{
		if (S1 -> Next[i] == S2 -> Next[i])
			++i;
		else
			break;
	}

	return S1 -> Next[i -1];
}

struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {
	if (root == NULL || p == NULL || q == NULL)
		return NULL;

	Stack S1, S2;
	Position P;
	S1 = Initialize();
	S2 = Initialize();

	if (!GetPathToNode(S1, root, p) || !GetPathToNode(S2, root, q))
		return NULL;

	P = GetMaxCommonNode(S1, S2);
	Destroy(S1);
	Destroy(S2);

	return P;
}

int main(int argc, char const *argv[])
{
  Tree T;
  Position P, P1, P2;
  T = CreateTree();

  PreOrderTraverse(T);
  printf("\n");

  InOrderTraverse(T);
  printf("\n");

  PostOrderTraverse(T);
  printf("\n");

  P1 = Find(T, 12);
  P2 = Find(T, 9);
 
  P = lowestCommonAncestor(T, P2, P1);
  printf("Position = %d\n", P -> val);
	return 0;
}#include <stdio.h>
#include <stdlib.h>

#include "tree.h"

#define Tree struct TreeNode*
#define Position struct TreeNode*

Tree NewNode(int value)
{
  Tree T;
  struct TreeNode node;
  T = (Tree)malloc(sizeof(struct TreeNode));
  T -> val = value;
  T -> left = T -> right = NULL;
  T -> next = &node;
  return T;
}

Tree Insert(int value, Tree T)
{
  if (T == NULL)
    return NewNode(value);

  // T -> left = Insert(value, T -> left);
  if (T -> val > value)
    T -> left = Insert(value, T -> left);
  else if (T -> val < value)
    T -> right = Insert(value, T -> right);

  return T;
}

void PreOrderTraverse(Tree T)
{
  if (T == NULL)
    return;

  printf("%d ", T -> val);
  PreOrderTraverse(T -> left);
  PreOrderTraverse(T -> right);
}

void InOrderTraverse(Tree T)
{
  if (T == NULL)
    return;

  InOrderTraverse(T -> left);
  printf("%d ", T -> val);
  InOrderTraverse(T -> right);
}

void PostOrderTraverse(Tree T)
{
  if (T == NULL)
    return;

  PostOrderTraverse(T -> left);
  PostOrderTraverse(T -> right);
  printf("%d ", T -> val);
}

Tree CreateTree()
{
  Tree T;
  int Len, i;
  // int Array[] = {1, 2};
  int Array[] = {5, 7, 4, 6, 9, 2};;

  // T = NULL;
  // Len = sizeof(Array) / sizeof(Array[0]);
  // Len = 0;
  // for (i = 0; i < Len; ++i)
  //   T = Insert(Array[i], T);
    // T = Insert(rand() % 1024, T);


  T = NewNode(1);
  // T -> left = NewNode(5);
  T -> right = NewNode(5);
  T -> right -> right = NewNode(7);
  T -> right -> right -> right = NewNode(17);
  T -> right -> right -> right -> right = NewNode(27);
  // T -> right -> right = NewNode(20);
  // T -> right -> left = NewNode(6);
  return T;
}

Position Find(Tree T, int Value)
{
  if (T == NULL)
    return NULL;

  if (T -> val > Value)
    return Find(T -> left, Value);
  else if (T -> val < Value)
    return Find(T -> right, Value);
  else
    return T;
}

void MakeEmpty(Tree T)
{
  if (T)
  {
    MakeEmpty(T -> left);
    MakeEmpty(T -> right);
    free(T);
  }

  return;
}

#undef Tree
#undef Position#include <stdio.h>

#include "test_stack.h"

#define Stack struct StackRecord*
#define MAX 2

extern Stack Initialize(int);
extern int Push(Stack, int);
extern int Pop(Stack);
extern void Destroy(Stack);
extern int IsEmpty(Stack);

int TestStack()
{
 Stack S;
 int i;

 S = Initialize(MAX);
 for (i = 0; i < 100; ++i)
   Push(S, i);

 while (!IsEmpty(S))
   printf("%d ", Pop(S));

 printf("\n");

 Destroy(S);
}

#undef Stack#include <stdlib.h>
#include <stdio.h>

#include "list.h"

#define Position struct ListNode* 
#define List struct ListNode* 

Position NewListNode(int Value)
{
  Position P;

  P = malloc(sizeof(struct ListNode));
  P -> val = Value;
  P -> next = NULL;

  return P;
}

void PrintList(List L)
{
  while (L != NULL)
  {
    printf("%d ", L -> val);
    L = L -> next;
  }

  printf("\n");
}

List CreateList(int Size)
{
  List L, *P;
  int i;

  L = NewListNode(0);
  P = L;
  for (i = 1; i <= Size; ++i)
  {
    P -> next = NewListNode(i);
    P = P -> next;    
  }

  return L;
}

List CreateDupList(int Size)
{
  List L, *P;
  int i, j;

  L = NewListNode(0);
  P = L;
  for (i = 1; i <= Size; ++i)
  {
    for (j = 0; j < i / 2; ++j)
    {
      P -> next = NewListNode(i);
      P = P -> next; 
    }   
  }

  return L;
}

List CreateIdenticalList(int Size)
{
  List L, *P;
  int i, j;

  L = NewListNode(0);
  P = L;
  for (i = 1; i <= Size; ++i)
  {
    P -> next = NewListNode(0);
    P = P -> next;  
  }

  return L;
}

List CreateRandList(int Size)
{
  List L, *P;
  int i;

  L = NewListNode(0);
  P = L;
  for (i = 1; i <= Size; ++i)
  {
    P -> next = NewListNode(rand() % (Size * 4));
    P = P -> next;    
  }

  return L;
}

List CreateReversedList(int Size)
{
  List L, *P;
  int i;

  L = NewListNode(Size);
  P = L;
  for (i = 1; i <= Size; ++i)
  {
    P -> next = NewListNode(Size - i);
    P = P -> next;    
  }

  return L;
}


List CreateOddList(int Size)
{
  List L, *P;
  int i;

  L = NewListNode(1);
  P = L;
  for (i = 1; i <= Size; ++i)
  {
    P -> next = NewListNode(2 * i + 1);
    P = P -> next;    
  }

  return L;
}

List CreateEvenList(int Size)
{
  List L, *P;
  int i;

  L = NewListNode(0);
  P = L;
  for (i = 1; i <= Size; ++i)
  {
    P -> next = NewListNode(2 * i);
    P = P -> next;    
  }

  return L;
}

Position Find(List L, int Value)
{
  while (L != NULL)
  {
    if (L -> val == Value)
      return L;

    L = L -> next;
  }

  return NULL;
}

void DestroyList(List L)
{
  List P;

  while (L != NULL)
  {
    P = L;
    L = L -> next;
    free(P);
  }
}

#undef Position
#undef List#include <stdio.h>

#include "test_queue.h"

#define Queue struct QueueRecord*

extern Queue Initialize(int);
extern int Enqueue(Queue, int);
extern int Dequeue(Queue);
extern void Destroy(Queue);

int TestQueue()
{
 Queue Q;
 int i;

 Q = Initialize(4);
 for (i = 0; i < 100; ++i)
   Enqueue(Q, i);

 while (!IsEmpty(Q))
   printf("%d ", Dequeue(Q));

 printf("\n");

 Destroy(Q);
}

#undef Queue// Write a program to find the n-th ugly number.

// Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.

// Note that 1 is typically treated as an ugly number.

#include <stdio.h>
#include <stdlib.h>

#define ElementType int
#define FIVE 5
#define TWO 2
#define THREE 3

typedef struct ListNode* Position;
typedef struct ListRecord* List;
typedef struct Item* PtrItem;

struct ListRecord
{
  Position Head;
  Position Last;
};

struct ListNode
{
  ElementType val;
  Position next;
};

struct Item
{
  Position P;
};

List Initialize()
{
  List L;

  L = malloc(sizeof(struct ListRecord));
  L -> Head = L -> Last = NULL;

  return L;
}

Position NewListNode(int Value)
{
  Position P;

  P = malloc(sizeof(struct ListNode));
  P -> next = NULL;
  P -> val = Value;
  return P;
}

void Insert(List L, int Value)
{
  if (L -> Head == NULL)
  {
    L -> Head = NewListNode(Value);
    L -> Last = L -> Head;
    return;
  }

  L -> Last -> next = NewListNode(Value);
  L -> Last = L -> Last -> next;
}

void Destroy(List L)
{
  Position P1, P2;

  for (P1 = L -> Head; P1 != NULL; )
  {
    P2 = P1 -> next;
    free(P1);
    P1 = P2;
  }

  free(L);
}

int GetMinOfThreeNum(PtrItem P1, PtrItem P2, PtrItem P3, PtrItem* TargetItem)
{
  int a, b, c;

  a = P1 -> P -> val * TWO;
  b = P2 -> P -> val * THREE;
  c = P3 -> P -> val * FIVE;

  if (a > b)
  {
    if (b < c)
    {
      *TargetItem = P2;
      return b;
    }
    else
    {
      *TargetItem = P3;           
      return c;
    }
  }
  else
  {
    if (a < c)
    {
      *TargetItem = P1;                 
      return a;
    }
    else
    {
      *TargetItem = P3;           
      return c;
    } 
  }
}

PtrItem NewItem()
{
  PtrItem Ptr;

  Ptr = malloc(sizeof(struct Item));
  Ptr -> P = NULL;

  return Ptr;
}

int nthUglyNumber(int n) {
  List L;
  PtrItem TwoItem, ThreeItem, FiveItem, TargetItem;
  Position P;
  int i, NextUglyNumber;

  TwoItem = NewItem();
  ThreeItem = NewItem();
  FiveItem = NewItem();

  L = Initialize();
  Insert(L, 1);
  TwoItem -> P = ThreeItem -> P = FiveItem -> P = L -> Head;

  i = 1;
  while (i < n)
  {
    NextUglyNumber = GetMinOfThreeNum(TwoItem, ThreeItem, FiveItem, &TargetItem);
    if (NextUglyNumber != L -> Last -> val)
    {
      Insert(L, NextUglyNumber);
      ++i;
    }
  
    TargetItem -> P = TargetItem -> P -> next;    
  }

  NextUglyNumber = L -> Last -> val;;
  Destroy(L);
  return NextUglyNumber;
}

// 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 
int main(int argc, char const *argv[])
{
  int i, n;

  // n = atoi(argv[1]);
  n = 10;
  for (i = 1; i <= n; ++i)
    printf("%d ", nthUglyNumber(i));

  printf("\n");
  return 0;
}// Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.

// For example,
// Given nums = [0, 1, 3] return 2.

// Note:
// Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?

#include <stdio.h>

int missingNumber(int* nums, int numsSize) {
  int i;
  int Sum1, Sum2;

  if (nums == NULL)
    return 0;

  Sum1 = Sum2 = 0;
  for (i = 0; i < numsSize; ++i)
  {
    Sum1 += i;
    Sum2 += nums[i];
  }

  Sum1 += numsSize;

  return Sum1 - Sum2;
}

int main(int argc, char const *argv[])
{
  int Numbers[] = {0, 1, 3};

  printf("%d\n", missingNumber(Numbers, 3));
  return 0;
}/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
#include <stdio.h>
#include <stdlib.h>
#include "lib/tree.h"

typedef struct TreeNode* Tree;
typedef struct TreeNode* Position;

#define ElementType Position
#define SIZE 2

struct QueueRecord
{
	int Capacity;
	int Rear;
	int Front;
	ElementType* Next;
};

typedef struct QueueRecord* Queue;

Queue Initialize()
{
	Queue Q;

	Q = malloc(sizeof(struct QueueRecord));
	Q -> Capacity = SIZE;
	Q -> Rear = Q -> Front = 0;
	Q -> Next = malloc(sizeof(ElementType) * SIZE);

	return Q;
}

int Succ(Queue Q, int Index)
{
	if (++Index >= Q -> Capacity)
		return Index % Q -> Capacity;

	return Index;
}

int IsEmpty(Queue Q)
{
	return Q -> Rear == Q -> Front;
}

int IsFull(Queue Q)
{
	return Succ(Q, Q -> Rear) == Q -> Front;
}

ElementType Dequeue(Queue Q)
{
	if (IsEmpty(Q))
	{
		fprintf(stderr, "Empty Queue\n");
		exit(1);
	}

	return Q -> Next[Q -> Front++];
}

Queue Rearrange(Queue Q)
{
	ElementType* Buffer;
	int i;

	Buffer = malloc(sizeof(ElementType) * Q -> Capacity * 2);
	i = 0;

	while (!IsEmpty(Q))
		Buffer[i++] = Dequeue(Q);

	Q -> Capacity *= 2;
	Q -> Front = 0;
	Q -> Rear = i;
	free(Q -> Next);
	Q -> Next = Buffer;

	return Q;
}

void Enqueue(Queue Q, ElementType X)
{
	if (IsFull(Q))
	{
		Q = Rearrange(Q);
	}

	Q -> Next[Q -> Rear++] = X;
}

void Destroy(Queue Q)
{
	free(Q -> Next);
	free(Q);
}

void PreorderTraversal(Tree T, Queue Q)
{
	if (T == NULL)
		return;

	Enqueue(Q, T);
	PreorderTraversal(T -> left, Q);
	PreorderTraversal(T -> right, Q);
}

void flatten(struct TreeNode* root) {
  if (root == NULL)
  	return;

  Queue Q;

  Q = Initialize();
  PreorderTraversal(root, Q);

  root = Dequeue(Q);

  while (!IsEmpty(Q))
  {
  	root -> right = Dequeue(Q);
  	root -> left = NULL;
  	root = root -> right;
  }

  Destroy(Q);
}

int main(int argc, char const *argv[])
{
	Tree T;

	T = CreateTree();

  PreOrderTraverse(T);
  printf("\n");

  InOrderTraverse(T);
  printf("\n");

  PostOrderTraverse(T);
  printf("\n");

  struct TreeNode node1, node2;
  node1.val = 1;
  node1.left = node1.right = NULL;

  node2.val = 2;
  node2.left = node2.right = NULL;
  node1.left = &node2;

  flatten(&node1);

  T = &node1;
  while (T)
  {
  	printf("%d ", T -> val);
  	T = T -> right;
  }	

  printf("\n");
  return 0;
}// Given a linked list, remove the nth node from the end of list and return its head.

// For example,

//    Given linked list: 1->2->3->4->5, and n = 2.

//    After removing the second node from the end, the linked list becomes 1->2->3->5.
// Note:
// Given n will always be valid.
// Try to do this in one pass.

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

#include <stdio.h>
#include <stdlib.h>

#include "lib/list.h"

typedef struct ListNode* Position;
typedef struct ListNode* List;

struct ListNode* removeNthFromEnd(struct ListNode* head, int n) {
	if (head == NULL)
		return NULL;

	Position P1, P2, P3;
	int i;

	P1 = head;
	for (i = 0; i < n; ++i)
		P1 = P1 -> next;

	P2 = head;

	while (P1 != NULL)
	{
		P3 = P2;
		P2 = P2 -> next;
		P1 = P1 -> next;
	}

	if (P2 == head)
		head = head -> next;
	else
		P3 -> next = P2 -> next;		

	return head;
}

int main(int argc, char const *argv[])
{
  List L1, L2, L;

	L1 = CreateEvenList(1);
  L2 = CreateOddList(10);
  PrintList(L1);
  PrintList(L2);

  L2 = removeNthFromEnd(L2, 2);
  PrintList(L2);
	return 0;
}// Given a sorted linked list, delete all duplicates such that each element appear only once.

// For example,
// Given 1->1->2, return 1->2.
// Given 1->1->2->3->3, return 1->2->3.

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

#include <stdio.h>

#include "lib/list.h"

typedef struct ListNode* Position;
typedef struct ListNode* List;

struct ListNode* deleteDuplicates(struct ListNode* head) {
  if (head == NULL)
    return NULL;

  Position P1, P2;
  int Value;

  Value = head -> val;
  P1 = head -> next;
  P2 = head;
  while (P1 != NULL)
  {
    if (P1 -> val != Value)
    {
      P2 -> next = P1;
      P2 = P2 -> next;
      Value = P1 -> val;
    } 

    P1 = P1 -> next;
  }

  P2 -> next = NULL;
  return head;
}

int main(int argc, char const *argv[])
{
  List L1, L2, L;

  L1 = CreateEvenList(10);
  L2 = CreateOddList(10);
  PrintList(L1);
  PrintList(L2);

  L1 = deleteDuplicates(L1);
  L2 = deleteDuplicates(L2);

  PrintList(L1);
  PrintList(L2);

  L1 = CreateDupList(10);
  PrintList(L1);
  L1 = deleteDuplicates(L1);
  PrintList(L1);

  return 0;
}/**
 * Note: The returned array must be malloced, assume caller calls free().
 */

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#define SIZE 19

typedef struct ListNode* Position;
typedef struct HashTbl* HashTable;

struct ListNode
{
	int Key;
	int Value;
	Position Next;
};

struct HashTbl
{
	int TableSize;
	Position *TheList;
};

HashTable Initialize()
{
	HashTable T;
	int i;

	T = malloc(sizeof(struct HashTbl));
	T -> TableSize = SIZE;
	T -> TheList = malloc(SIZE * sizeof(struct ListNode));

	for (i = 0; i < T -> TableSize; ++i)
		T -> TheList[i] = NULL;

	return T;
}

int Hash(int Key,HashTable H)
{
	if (Key < 0)
		Key *= -1;

	return Key % (H -> TableSize);
}

Position Find(int Key, HashTable H)
{
	Position List;
	List = H -> TheList[Hash(Key, H)];

	while (List)
	{
		if (List -> Key == Key)
			return List;

		List = List -> Next;
	}

	return NULL;
}

void Insert(int Key, int Value, HashTable H)
{
	Position P, List, Node;
	int hash;

	P = Find(Key, H);

	if (P != NULL)
		return;

	hash = Hash(Key, H);
	List = H -> TheList[hash];
	Node = malloc(sizeof(struct ListNode));
	Node -> Key = Key;
	Node -> Value = Value;
	Node -> Next = NULL;

	if (List == NULL)
	{
		H -> TheList[hash] = Node;
		return;
	}	

	Node -> Next = List -> Next;
	List -> Next = Node;

	return;
}

void freeHashTbl(HashTable H)
{
	int i;
	Position P1, P2;

	for (i = 0; i < H -> TableSize; ++i)
	{
		P1 = H -> TheList[i];

		while (P1)
		{
			P2 = P1 -> Next;
			free(P1);
			P1 = P2;
		}
	}
}

int* twoSum(int* nums, int numsSize, int target) {
    int i;
    int *Result;
    HashTable H;
    Position P;

    H = Initialize();
    for (i = 0; i < numsSize; ++i)
    {
    	P = Find(target - nums[i], H);

    	if (P != NULL)
    	{
    		Result = malloc(sizeof(int) * 2);
    		Result[0] = P -> Value + 1;
    		Result[1] = i + 1;

    		freeHashTbl(H);
    		return Result;
    	}

    	Insert(nums[i], i, H);
    }

    freeHashTbl(H);
    return NULL;
}

// int* twoSum(int* nums, int numsSize, int target) {
// 	int i, j;
// 	int* Result;

// 	for (i = 0; i < numsSize; ++i)
// 		for (j = i; j < numsSize; ++j)
// 		{
// 			if (nums[i] + nums[j] == target)
// 			{
// 				Result = malloc(sizeof(int) * 2);
// 				Result[0] = i + 1;
// 				Result[1] = j + 1;
// 				return Result;
// 			}
// 		}


// 	return NULL;
// }

int main(int argc, char const *argv[])
{
	int array[] = {1, 14, 13, 2, 3, 4, 5, 7, 8};
	int a1[] = {2, 7, 11, 15};
	int a2[] = {2, 3, 11, 15, 7};
	int a3[] = {2, 3, 11, 15};
	int a4[] = {-3, 4, 3, 90};
	int a5[] = {591,955,829,805,312,83,764,841,12,744,104,773,627,306,731,539,349,811,662,341,465,300,491,423,569,405,508,802,500,747,689,506,129,325,918,606,918,370,623,905,321,670,879,607,140,543,997,530,356,446,444,184,787,199,614,685,778,929,819,612,737,344,471,645,726};
	int *Result;
	HashTable H;
	int i, Len;
	Position P;

	H = Initialize();
	Len = sizeof(array) / sizeof(array[0]);
	for (i = 0; i < Len - 2; ++i)
		Insert(array[i], array[i] * 3, H);

	for (i = 0; i < Len -2; ++i)
	{
		P = Find(array[i], H);
		assert(P -> Value == array[i] * 3);
	}

	for (; i < Len; ++i)
	{
		P = Find(array[i], H);
		assert(P == NULL);		
	}

	Result = twoSum(a1, sizeof(a1) / sizeof(a1[0]), 9);
	assert(Result[0] == 1);
	assert(Result[1] == 2);

	Result = twoSum(a2, sizeof(a2) / sizeof(a2[0]), 9);
	assert(Result[0] == 1);
	assert(Result[1] == 5);

	Result = twoSum(a3, sizeof(a3) / sizeof(a3[0]), 9);
	assert(Result == NULL);

	Result = twoSum(a4, sizeof(a4) / sizeof(a4[0]), 0);
	assert(Result[0] == 1);
	assert(Result[1] == 3);

	Result = twoSum(a5, sizeof(a5) / sizeof(a5[0]), 789);
	printf("%d %d\n", Result[0], Result[1]);
	printf("%d %d", a5[Result[0] - 1], a5[Result[1] - 1]);
	printf("\n");
	return 0;
}// Reverse digits of an integer.

// Example1: x = 123, return 321
// Example2: x = -123, return -321

#include <stdio.h>
#include <limits.h>

int reverse(int x) {
  if (x == 0)
    return 0;

  int Positive;
  long Value;

  Positive = 1;
  Value = 0;

  if (x < 0)
  {
    Positive = -1;
    x = x * -1;
  }

  while (x > 0)
  {
    Value = Value * 10 + x % 10;
    x /= 10;

    if (Value > INT_MAX)
      return 0;
  }

  return (int)Positive * Value;
}

int main(int argc, char const *argv[])
{
  int N;

  N = 32;
  printf("%d\n", reverse(N));
  printf("%d\n", INT_MAX);
  return 0;
}/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

#include <stdio.h>
#include <stdlib.h>
#include "lib/tree.h"

typedef struct TreeNode* Tree;
typedef struct TreeNode* Position;

struct TreeNode* sortedArrayToBST(int* nums, int numsSize) {
  if (nums == NULL || numsSize == 0)
    return NULL;

  int Mid;
  Tree Root;

  Mid = numsSize / 2;
  Root = NewNode(nums[Mid]);

  Root -> left = sortedArrayToBST(nums, Mid);
  Root -> right = sortedArrayToBST(nums + Mid + 1, numsSize - Mid - 1);

  return Root;
}

int main(int argc, char const *argv[])
{
  int i, Len;
  int* Array;
  Tree T;

  Len = 16;
  Array = malloc(sizeof(int) * Len);

  for (i = 0; i < Len; ++i)
    Array[i] = i;

  T = sortedArrayToBST(Array, Len);

  PreOrderTraverse(T);
  printf("\n");

  InOrderTraverse(T);
  printf("\n");

  PostOrderTraverse(T);
  printf("\n");

  return 0;
}

// Given two strings s and t, write a function to determine if t is an anagram of s.

// For example,
// s = "anagram", t = "nagaram", return true.
// s = "rat", t = "car", return false.

// Note:
// You may assume the string contains only lowercase alphabets.

#include <stdio.h>
#include <stdlib.h>

#define LEN 26

int isAnagram(char* s, char* t) {
  int i;
  int S1[26] = {0};
  int S2[26] = {0};

  if (s == NULL && t == NULL)
    return 1;

  if (s == NULL || t == NULL)
    return 0;

  while (*s != '\0' && *t != '\0')
  {
    S1[*s - 'a'] += 1;
    S2[*t - 'a'] += 1;
    ++s, ++t;
  }

  if (*s != '\0' || *t != '\0')
    return 0;

  for (i = 0; i < LEN; ++i)
  {
    if (S1[i] != S2[i])
      return 0;
  }

  return 1;
}

int main(int argc, char const *argv[])
{
  char *t = "abc";
  char *s = "bcda";

  printf("%d\n", isAnagram(s, t));
  return 0;
}// Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.

// For example:
// Given the below binary tree and sum = 22,
//               5
//              / \
//             4   8
//            /   / \
//           11  13  4
//          /  \      \
//         7    2      1
// return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.


/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

#include <stdio.h>
#include "lib/tree.h"

typedef struct TreeNode* Tree;
typedef struct TreeNode* Position;

bool hasPathSum(struct TreeNode* root, int sum) 
{
	if (root == NULL)
		return false;

	if (root -> val == sum && root -> left == NULL && root -> right == NULL)
		return true;

	return hasPathSum(root -> left, sum - root -> val) || hasPathSum(root -> right, sum - root -> val);
}

int main(int argc, char const *argv[])
{
	Tree T;

	T = CreateTree();

	PreOrderTraverse(T);
	printf("\n");

	InOrderTraverse(T);
	printf("\n");

	PostOrderTraverse(T);
	printf("\n");

	printf("%d\n", hasPathSum(T, 0));
	return 0;
}
// Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.

// You may assume that the array is non-empty and the majority element always exist in the array.

#include <stdio.h>

int majorityElement(int* nums, int numsSize) {
	int Number, Value, i;

	if (nums == NULL || numsSize == 0)
		return 0;

	if (numsSize == 1)
		return nums[0];

	Number = 1;
	Value = nums[0];

	for (i = 1; i < numsSize; ++i)
	{
		if (Value != nums[i])
		{
			--Number;

			if ((Number == 0) && (i + 1 < numsSize))
			{
				Value = nums[++i];
				++Number;				
			}
		}
		else
		{
			++Number;
		}
	}

	return Value;
}

int main(int argc, char const *argv[])
{
	int Numbers[] = {2,2,1,1,1,2,2};

	printf("%d\n", majorityElement(Numbers, sizeof(Numbers) / sizeof(Numbers[0])));
	return 0;
}// Given two strings s and t, determine if they are isomorphic.

// Two strings are isomorphic if the characters in s can be replaced to get t.

// All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.

// For example,
// Given "egg", "add", return true.

// Given "foo", "bar", return false.

// Given "paper", "title", return true.

// Note:
// You may assume both s and t have the same length.

#include <stdio.h>

int checkIsmorphic(char* s, char* t)
{
	char Map[127] = {0};
	int Index;
	
	while (*s != '\0' && *t != '\0')
	{
		Index = *s;
		if (Map[Index] == 0)
			Map[Index] = *t;
		else
		{
			if (Map[Index] != *t)
				return 0;
		}

		++s, ++t;
	}

	return 1;
}

int isIsomorphic(char* s, char* t) {
	return checkIsmorphic(s, t) && checkIsmorphic(t, s);
}

int main(int argc, char const *argv[])
{
	char *s = "qwertyuiop[]asdfghjkl;'\\zxcvbnm,./";
	char *t = "',.pyfgcrl/=aoeuidhtns-\\;qjkxbmwvz";

	printf("%d\n", isIsomorphic(t, s));
	return 0;
}// Given a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for "abcabcbb" is "abc", which the length is 3. For "bbbbb" the longest substring is "b", with the length of 1.

#include <stdio.h>


// abcabcbb

int lengthOfLongestSubstring(char* s) {
  int Map[127] = {0};
  char *P1, *P2;
  int Length, Index;

  if (s == NULL || *s == '\0')
    return 0;

  P1 = s;
  P2 = s + 1;
  Length = 1;
  Map[*P1] = 1;

  while (*P2 != '\0')
  {
    Index = *P2;
    if (Map[Index] != 0)
    {
      while (*P1 != *P2)
      {
        Map[*P1] = 0;
        ++P1;       
      }

      ++P1;
    }
    else
    {
      Map[Index] = 1;
      
      if (P2 - P1 + 1 > Length)
        Length = P2 - P1 + 1;
    }

    ++P2;
  }

  if (P2 - P1 > Length)
    Length = P2 - P1;
  
  return Length;
}

int main(int argc, char const *argv[])
{
  char Str[] = "tmmzuxt";

  printf("%d\n", lengthOfLongestSubstring(Str));
  return 0;
}/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
/**
 * Return an array of size *returnSize.
 * Note: The returned array must be malloced, assume caller calls free().
 */

#include <stdlib.h>
#include <stdio.h>

#include "lib/tree.h"

#define SIZE 8

typedef struct Stack* Stack;
typedef struct TreeNode* Tree;
typedef struct TreeNode* Position;
typedef struct PostOrderNode* PNode;

#define ElementType PNode

struct PostOrderNode {
	int isFirst;
	Position P;
};

struct Stack {
	ElementType* next;
	int size;
	int capacity;
};


Stack initialize()
{
	Stack S;

	S = malloc(sizeof(struct Stack));
	S -> next = malloc(SIZE * sizeof(ElementType));
	S -> size = 0;
	S -> capacity = SIZE;
	return S;
}

ElementType pop(Stack S)
{
	return S -> next[--S -> size];
}

int isEmpty(Stack S)
{
	return S -> size == 0;
}

void push(Stack S, ElementType value)
{
	if (S -> size == S -> capacity)
	{
		S -> next = realloc(S -> next, S -> capacity * 2 * sizeof(ElementType));
		S -> capacity *= 2;
	}

	S -> next[S -> size++] = value;
}

void destory(Stack S)
{
	free(S -> next);
	free(S);
}

void pushBuffer(int** buffer, int value, int *i, int *capacity)
{
	if (*i == *capacity)
	{
		*buffer = realloc(*buffer, *capacity * 2 * sizeof(int));
		*capacity = *capacity * 2;
	}

	(*buffer)[(*i)++] = value;
}

PNode NewPNode(Position P)
{
	PNode node;

	node = malloc(sizeof(struct PostOrderNode));
	node -> isFirst = 1;
	node -> P = P;

	return node;
}

int* inorderTraversal(struct TreeNode* root, int* returnSize) {
		if (root == NULL)
		{
			returnSize = 0;
			return NULL;
		}

    Stack S;
    Tree T;
    int* buffer;
    int i, capacity;
		PNode node;
    
    buffer = malloc(sizeof(int) * SIZE);
    capacity = SIZE;
    i = 0;

    S = initialize();
    push(S, NewPNode(root));
    while(!isEmpty(S))
    {
    	node = pop(S);

    	if (node -> isFirst)
    	{
    		node -> isFirst = 0;

    		if (node -> P -> right)
	    		push(S, NewPNode(node -> P -> right));

    		push(S, node);

	    	if (node -> P -> left)
	    		push(S, NewPNode(node -> P -> left));
    	}
    	else
    	{
    		// printf("%d ", node -> P -> val);
    		pushBuffer(&buffer, node -> P -> val, &i, &capacity);
    		free(node);
    	}
    }

    *returnSize = i;
    return buffer;
}

int main(int argc, char const *argv[])
{
	Tree T;
	int Len, i, returnSize;
	int* array;

	T = NULL;
	Len = 64;
	for (i = 0; i < Len; ++i)
		T = Insert(rand() % 1024, T);

	PreOrderTraverse(T);
	printf("\n");

	InOrderTraverse(T);
	printf("\n");

	array = inorderTraversal(T, &returnSize);
	printf("%d\n", returnSize);

	for (i = 0; i < returnSize; ++i)
		printf("%d ", array[i]);
	printf("\n");
	return 0;
}/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
/**
 * Return an array of size *returnSize.
 * Note: The returned array must be malloced, assume caller calls free().
 */

#include <stdlib.h>
#include <stdio.h>

#include "lib/tree.h"

#define SIZE 8

typedef struct Stack* Stack;
typedef struct TreeNode* Tree;
typedef struct TreeNode* Position;
typedef struct PostOrderNode* PNode;

#define ElementType PNode

struct PostOrderNode {
	int isFirst;
	Position P;
};

struct Stack {
	ElementType* next;
	int size;
	int capacity;
};


Stack initialize()
{
	Stack S;

	S = malloc(sizeof(struct Stack));
	S -> next = malloc(SIZE * sizeof(ElementType));
	S -> size = 0;
	S -> capacity = SIZE;
	return S;
}

ElementType pop(Stack S)
{
	return S -> next[--S -> size];
}

int isEmpty(Stack S)
{
	return S -> size == 0;
}

void push(Stack S, ElementType value)
{
	if (S -> size == S -> capacity)
	{
		S -> next = realloc(S -> next, S -> capacity * 2 * sizeof(ElementType));
		S -> capacity *= 2;
	}

	S -> next[S -> size++] = value;
}

void destory(Stack S)
{
	free(S -> next);
	free(S);
}

void pushBuffer(int** buffer, int value, int *i, int *capacity)
{
	if (*i == *capacity)
	{
		*buffer = realloc(*buffer, *capacity * 2 * sizeof(int));
		*capacity = *capacity * 2;
	}

	(*buffer)[(*i)++] = value;
}

PNode NewPNode(Position P)
{
	PNode node;

	node = malloc(sizeof(struct PostOrderNode));
	node -> isFirst = 1;
	node -> P = P;

	return node;
}

int* postorderTraversal(struct TreeNode* root, int* returnSize) {
		if (root == NULL)
		{
			returnSize = 0;
			return NULL;
		}

    Stack S;
    Tree T;
    int* buffer;
    int i, capacity;
		PNode node;
    
    buffer = malloc(sizeof(int) * SIZE);
    capacity = SIZE;
    i = 0;

    S = initialize();
    push(S, NewPNode(root));
    while(!isEmpty(S))
    {
    	node = pop(S);

    	if (node -> isFirst)
    	{
    		node -> isFirst = 0;
    		push(S, node);

    		if (node -> P -> right)
	    		push(S, NewPNode(node -> P -> right));
	    	if (node -> P -> left)
	    		push(S, NewPNode(node -> P -> left));
    	}
    	else
    	{
    		// printf("%d ", node -> P -> val);
    		pushBuffer(&buffer, node -> P -> val, &i, &capacity);
    		free(node);
    	}
    }

    *returnSize = i;
    return buffer;
}

int main(int argc, char const *argv[])
{
	Tree T;
	int Len, i, returnSize;
	int* array;

	T = NULL;
	Len = 0;
	for (i = 0; i < Len; ++i)
		T = Insert(rand() % 1024, T);

	PreOrderTraverse(T);
	printf("\n");

	PostOrderTraverse(T);
	printf("\n");

	array = postorderTraversal(T, &returnSize);
	printf("%d\n", returnSize);

	for (i = 0; i < returnSize; ++i)
		printf("%d ", array[i]);
	printf("\n");
	return 0;
}// Given a binary tree

//     struct TreeLinkNode {
//       TreeLinkNode *left;
//       TreeLinkNode *right;
//       TreeLinkNode *next;
//     }
// Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

// Initially, all next pointers are set to NULL.

// Note:

// You may only use constant extra space.
// You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).
// For example,
// Given the following perfect binary tree,
//          1
//        /  \
//       2    3
//      / \  / \
//     4  5  6  7
// After calling your function, the tree should look like:
//          1 -> NULL
//        /  \
//       2 -> 3 -> NULL
//      / \  / \
//     4->5->6->7 -> NULL

/**
 * Definition for binary tree with next pointer.
 * struct TreeLinkNode {
 *  int val;
 *  struct TreeLinkNode *left, *right, *next;
 * };
 *
 */

#include <stdio.h>

#include "lib/tree.h"

// struct TreeNode {
//   int val;
//   struct TreeNode* left, *right, *next;
// };

typedef struct TreeNode* Position;
typedef struct TreeNode* Tree;

void connect(struct TreeNode *root) {
  if (root == NULL)
    return;

  Position P1, P2;
  Position PtrStart;

  P1 = P2 = NULL;
  P1 = root;
  P1 -> next = NULL;
  PtrStart = P1 -> left;

  while (P1 != NULL && P1 -> left != NULL)
  {
    P1 -> left -> next = P1 -> right;

    if (P1 -> next == NULL)
    {
      P1 -> right -> next = NULL;
      P1 = PtrStart;
      PtrStart = P1 -> left;
    }
    else
    {
      P2 = P1;
      P1 = P1 -> next;
      P2 -> right -> next = P1 -> left;
    }
  }
}

int main(int argc, char const *argv[])
{
  Tree T, T2;

  T = CreateTree();
  PreOrderTraverse(T);
  printf("\n");

  InOrderTraverse(T);
  printf("\n");

  PostOrderTraverse(T);
  printf("\n");

  connect(T);
  return 0;
}// Description:

// Count the number of prime numbers less than a non-negative number, n.

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>

#define MAX 2
typedef struct DynamicArray* DynArray;

struct DynamicArray
{
	int* Next;
	int Capacity;
	int Size;
};

int IsPrime(int N)
{
	int i;

	for (i = 2; i * i <= N; ++i)
	{
		if (N % i == 0)
			return 0;
	}

	return 1;
}

int countPrimes1(int n) {
	int i, Number;

	for (Number = 0, i = 2; i < n; ++i)
	{
		if (IsPrime(i) == 1)
			++Number;
	}

	return Number;
}

DynArray Initialize(int Capacity)
{
	DynArray DA;

	DA = malloc(sizeof(struct DynamicArray));
	DA -> Capacity = Capacity;
	DA -> Size = 0;
	DA -> Next = malloc(sizeof(int) * Capacity);

	return DA;
}

void AddToArray(DynArray DA, int Value)
{
	if (DA -> Size == DA -> Capacity)
	{
		DA -> Next = realloc(DA -> Next, 2 * DA -> Capacity * sizeof(int));
		DA -> Capacity *= 2;
	}

	DA -> Next[DA -> Size++] = Value;
}

int* GetAllFactors(int N, int* PtrSize)
{
	int i;
	DynArray DA;

	DA = Initialize(MAX);
	for (i = 2; i * i <= N; ++i)
	{
		if (IsPrime(i) == 1)
			AddToArray(DA, i);
	}

	*PtrSize = DA -> Size;
	return DA -> Next;
}

int countPrimes2(int n)
{
	int *Buffer, *Factors;
	int Size, Number, i, j;

	Buffer = malloc(sizeof(int) * n);
	memset(Buffer, 0, n * sizeof(int));

	Factors = GetAllFactors(n, &Size);

	for (i = 0; i < Size; ++i)
	{
		j = Factors[i];
		while (j * Factors[i] < n)
		{
			Buffer[j * Factors[i]] = 1;
			++j;
		}
	}

	for (Number = 0, i = 2; i < n; ++i)
	{
		if (Buffer[i] == 0)
			Number++;
	}

	free(Factors);
	free(Buffer);
	return Number;
}

int countPrimes(int n)
{
	int *Buffer;
	int Number, i, j;

	Buffer = malloc(sizeof(int) * n);
	memset(Buffer, 0, n * sizeof(int));

	for (i = 2; i * i <= n; ++i)
	{
		if (!IsPrime(i))
			continue;
			
		for (j = i; j * i < n; ++j)
		{
			Buffer[i * j] = 1;
		}
	}

	for (Number = 0, i = 2; i < n; ++i)
	{
		if (Buffer[i] == 0)
			Number++;
	}

	free(Buffer);
	return Number;
}

int main(int argc, char const *argv[])
{
	int N;

	N = 100;

	printf("%d\n", countPrimes(N));
	return 0;
}// Implement a basic calculator to evaluate a simple expression string.

// The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces .

// You may assume that the given expression is always valid.

// Some examples:
// "1 + 1" = 2
// " 2-1 + 2 " = 3
// "(1+(4+5+2)-3)+(6+8)" = 23

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define ElementType int
#define SIZE 8
#define Parenthesis -1
#define Minus -2
#define Plus -3
#define IsDigit(x) ((x) >= '0' && (x) <= '9')
#define IsOp(x) ((x) == '+' || (x) == '-')
#define IsLeftParen(x) ((x) == '(')
#define IsRightParen(x) ((x) == ')')
#define IsSpace(x) ((x) == ' ')

struct Stack
{
  int Size;
  int Capacity;
  ElementType* Next;
};

typedef struct Stack* Stack;

Stack Initialize()
{
  Stack S;

  S = malloc(sizeof(struct Stack));
  S -> Next = malloc(sizeof(ElementType) * SIZE);
  S -> Size = 0;
  S -> Capacity = SIZE;

  return S; 
}

int IsEmpty(Stack S)
{
  return S -> Size == 0;
}

int IsFull(Stack S)
{
  return S -> Size == S -> Capacity;
}

void Destroy(Stack S)
{
  free(S -> Next);
  free(S);
}

void Push(Stack S, ElementType Value)
{
  if (IsFull(S))
  {
    S -> Next = realloc(S -> Next, sizeof(ElementType) * 2 * S -> Capacity);
    S -> Capacity *= 2;
  }

  S -> Next[S -> Size++] = Value;
}

ElementType Pop(Stack S)
{
  if (IsEmpty(S))
  {
    printf("Empty Stack\n");
    exit(1);
  }

  return S -> Next[--S -> Size];
}

ElementType Top(Stack S)
{
  if (IsEmpty(S))
  {
    printf("Empty Stack\n");
    exit(1);
  }

  return S -> Next[S -> Size - 1];
}

int Evaluate(int Op1, int Op2, char Op)
{
  if (Op == '+')
    return Op1 + Op2;
  else if (Op == '-')
    return Op1 - Op2;
}

void PushDigitToStack(Stack S, int Value)
{
  int X, Op1, Op2, Operator;

  while (1)
  {
    if (IsEmpty(S))
    {
      Push(S, Value);
      break;
    }
    else
    {
      X = Top(S);

      if (X == Plus || X == Minus)        
      {
        Op2 = Value;
        Operator = Pop(S) == Plus ? '+' : '-';
        Op1 = Pop(S);
        Value = Evaluate(Op1, Op2, Operator);
      }
      else
      {
        Push(S, Value);
        break;
      }
    }
  }
}

int SubStringToInt(char* pBegin, char* pEnd)
{
  int i = 0;

  while(pBegin != pEnd)
  {
    i = i * 10 + *pBegin - '0';
    ++pBegin;
  }

  return i;
}

int calculate(char* s) {
    char* Ptr, *Targets, *Parenthesises, *PtrParen, *PtrTarget, *Numbers; 
    char* PtrEnd;
    char Operator;
    int Op1, Op2, Value;
    Stack S;

    Ptr = s;
    Targets = "0123456789()";
    Numbers = "0123456789";
    S = Initialize();

    while(*Ptr != '\0')
    {
      if (IsDigit(*Ptr))
      {
        PtrEnd = Ptr + 1 + strspn(Ptr + 1, Numbers);
        Value = SubStringToInt(Ptr, PtrEnd);
        PushDigitToStack(S, Value);
        Ptr = PtrEnd;
        continue;
      }
      else if (IsOp(*Ptr))
      {
        PtrTarget = strpbrk(Ptr + 1, Targets);

        if (IsDigit(*PtrTarget))
        {
          Op1 = Pop(S);
          Operator = *Ptr;
  
          PtrEnd = PtrTarget + 1 + strspn(PtrTarget + 1, Numbers);
          Value = SubStringToInt(PtrTarget, PtrEnd);
          Ptr = PtrEnd;
          Op2 = Value;
          Push(S, Evaluate(Op1, Op2, Operator));
          continue;
        }
        else
        {
          if (*Ptr == '+')
            Push(S, Plus);
          else if (*Ptr == '-')
            Push(S, Minus);

          Ptr = PtrTarget;
          Push(S, Parenthesis);
        }
      }
      else if (IsSpace(*Ptr))
      {
      }
      else if (IsLeftParen(*Ptr))
      {
        Push(S, Parenthesis);
      }
      else if (IsRightParen(*Ptr))
      {
        // Get digit from stack
        Value = Pop(S);
        // Pop left parenthesis
        Pop(S);
        // Push digit back to stack
        PushDigitToStack(S, Value);
      }

      ++Ptr;
    }

    if (S -> Size != 1)
    {
      fprintf(stderr, "Error Expression\n");
      exit(1);
    }

    Value = Pop(S);
    Destroy(S);
    return Value;
}

int main(int argc, char const *argv[])
{
  // "1 + 1" = 2
  // " 2-1 + 2 " = 3
  // "(1+(4+5+2)-3)+(6+8)" = 23

  char *Expression1 = "1 + 1";
  char *Expression2 = " 2-1 + 2 ";
  char *Expression3 = "(1+(4+5+2)-3)+(6+8)";
  char *Expression4 = "2147483647";
  char *Expression5 = "1-11";

  int Result;

  Result = calculate(Expression1);
  printf("%d\n", Result);

  Result = calculate(Expression2);
  printf("%d\n", Result);

  Result = calculate(Expression3);
  printf("%d\n", Result);

  Result = calculate(Expression4);
  printf("%d\n", Result);

  Result = calculate(Expression5);
  printf("%d\n", Result);
  return 0;
}// Given a linked list, return the node where the cycle begins. If there is no cycle, return null.

// Follow up:
// Can you solve it without using extra space?

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

#include <stdio.h>

#include "lib/list.h"

typedef struct ListNode* Position;
typedef struct ListNode* List;

Position GetNodeOfCycle(List Head)
{
	Position P1, P2;
	
	P1 = P2 = Head;

	while (P1 != NULL)
	{
		P2 = P2 -> next;
		if (P1 -> next == NULL)
			return NULL;
		P1 = P1 -> next -> next;

		if (P1 == P2)
			return P1;
	}

	return NULL;
}

int GetLengthOfList(List L)
{
	int i;

	i = 0;

	while (L != NULL)
	{
		++i;
		L = L -> next;
	}

	return i;
}

Position GetIntersectionOfLists(List L1, List L2)
{
	int Len1, Len2, i;

	Len1 = GetLengthOfList(L1);
	Len2 = GetLengthOfList(L2);

	if (Len1 > Len2)
	{
		for (i = 0; i < Len1 - Len2; ++i)
			L1 = L1 -> next;
	}

	if (Len1 < Len2)
	{
		for (i = 0; i < Len2 - Len1; ++i)
			L2 = L2 -> next;
	}

	while (L1 != NULL)
	{
		if (L1 == L2)
			return L1;

		L1 = L1 -> next;
		L2 = L2 -> next;
	}

	return NULL;
}

struct ListNode *detectCycle(struct ListNode *head) {
	if (head == NULL)
		return NULL;

	Position CycleNode;
	List NewHead;
	CycleNode = GetNodeOfCycle(head);

	if (CycleNode == NULL)
		return NULL;

	NewHead = CycleNode -> next;
	CycleNode -> next = NULL;

	return GetIntersectionOfLists(head, NewHead);
}

int main(int argc, char const *argv[])
{
	List L;
  Position P1, P2;
  int i;

  L = CreateList(15);
  PrintList(L);

 //  for (P1 = L; P1 -> next != NULL; P1 = P1 -> next);
 //  P2 = L;
	// for (i = 0; i < 1; ++i)
	// 	P2 = P2 -> next;
	// P1 -> next = P2;

	printf("%d\n", detectCycle(L) -> val);
	return 0;
}// Given an array of integers, every element appears twice except for one. Find that single one.

// Note:
// Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?

#include <stdio.h>

int singleNumber(int* nums, int numsSize) {
	if (nums == NULL || numsSize == 0)
		return 0;

	int Result, i;

	Result = 0;
	for (i = 0; i < numsSize; ++i)
		Result ^= nums[i];

	return Result;
}

int main(int argc, char const *argv[])
{
	int Numbers[] = {1, 2, 3, 2, 1};

	printf("%d\n", singleNumber(Numbers, sizeof(Numbers) / sizeof(Numbers[1])));
	return 0;
}/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

#include <stdio.h>
#include <stdlib.h>
#include "lib/tree.h"

typedef struct TreeNode* Tree;
typedef struct TreeNode* Position;

#define LEFT 0
#define RIGHT 1

Tree LCA(Tree Root, Tree Left, Tree Right)
{
  if (Root == NULL)
    return NULL;

  if (Root -> val >= Left -> val && Root -> val <= Right -> val)
    return Root;
  else if (Root -> val > Right -> val)
    return LCA(Root -> left, Left, Right);
  else if (Root -> val < Left -> val)
    return LCA(Root -> right, Left, Right);
}

struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {
  if (root == NULL || p == NULL || q == NULL)
    return NULL;

  if (p -> val > q -> val)
    return LCA(root, q, p);

  return LCA(root, p, q);
}

int main(int argc, char const *argv[])
{
  Tree T;
  Position P, P1, P2;
  T = CreateTree();

  PreOrderTraverse(T);
  printf("\n");

  InOrderTraverse(T);
  printf("\n");

  PostOrderTraverse(T);
  printf("\n");

  P1 = Find(T, 10);
  P2 = Find(T, 15);
 
  P = lowestCommonAncestor(T, P2, P1);
  printf("Position = %d\n", P -> val);
  return 0;
}/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
 
// typedef struct ListNode* ListNode;
typedef struct ListNode* Position;

struct ListNode {
	int val;
	struct ListNode* next;
};

Position NewNode(int value)
{
	Position P;

	P = malloc(sizeof(struct ListNode));
	P -> val = value;
	P -> next = NULL;
	return P;
}

struct ListNode* initList(int* array, int size)
{
	if (size <= 0)
		return NULL;

	Position head, list, node;
	head = NewNode(array[0]);
	list = head;
	int i;

	for (i = 1; i < size; ++i)
	{
		node = NewNode(array[i]);
		list -> next = node;
		list = list -> next;
	}

	return head;
}

void printList(struct ListNode* list)
{
	while (list != NULL)
	{
		printf("%d ", list -> val);
		list = list -> next;
	}
	printf("\n");;
}

void freeList(struct ListNode *list)
{
	Position node;

	while (list != NULL)
	{
		node = list;
		free(node);
		list = list -> next;
	}
}

int getValueAndMoveNext(struct ListNode** l1)
{
	int value;

	value = 0;
	if (*l1)
	{
		value = (*l1) -> val;
		*l1 = (*l1) -> next;
	}

	return value;
}

struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {
  struct ListNode *head, **list;
  int value, carry, sum, val1, val2;

  if (l1 == NULL)
  	return l2;

  if (l2 == NULL)
  	return l1;

  carry = 0;
  head = NULL;
  list = &head;
  while (l1 != NULL || l2 != NULL)
  {
  	val1 = getValueAndMoveNext(&l1);
  	val2 = getValueAndMoveNext(&l2);
  	sum = carry + val1 + val2;
  	carry = sum >= 10 ? 1 : 0;
  	value = sum >= 10 ? sum - 10 : sum;
  	*list = NewNode(value);
  	list = &((*list) -> next);
  }

  if (carry > 0)
  {
  	*list = NewNode(carry);
  }

  return head;  
}



void testListArray(struct ListNode* list, int* array, int size)
{
	int i;

	for (i = 0; i < size; ++i)
	{
		assert(list -> val == array[i]);
		list = list -> next;
	}

	assert(list == NULL);
}

void testCase(int* a1, int len1, int* a2, int len2, int* res, int resLen)
{
	struct ListNode *l1, *l2, *list;

	l1 = initList(a1, len1);
	l2 = initList(a2, len2);

	list = addTwoNumbers(l1, l2);
	testListArray(list, res, resLen);

	freeList(l1);
	freeList(l2);
	freeList(list);
}

void testWithSameLength()
{
	int a1[] = {2, 4, 3};
	int a2[] = {5, 6, 4};
	int res[] = {7, 0, 8};

	testCase(a1, sizeof(a1) / sizeof(a1[0]), a2, sizeof(a2) / sizeof(a2[0]), res, sizeof(res) / sizeof(res[0]));
}

void testWithDifferentLength()
{
	int a1[] = {2, 4, 3};
	int a2[] = {5, 6, 9, 8};
	int res[] = {7, 0, 3, 9};

	testCase(a1, sizeof(a1) / sizeof(a1[0]), a2, sizeof(a2) / sizeof(a2[0]), res, sizeof(res) / sizeof(res[0]));
}

void testWithEmptyArray()
{
	int a1[] = {2, 4, 3};
	int a2[] = {};
	int res[] = {2, 4, 3};

	testCase(a1, sizeof(a1) / sizeof(a1[0]), a2, sizeof(a2) / sizeof(a2[0]), res, sizeof(res) / sizeof(res[0]));
}

int main(int argc, char const *argv[])
{
	// (2 -> 4 -> 3) + (5 -> 6 -> 4)
	testWithDifferentLength();
	testWithSameLength();
	testWithEmptyArray();
	return 0;
}// Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.

// Supposed the linked list is 1 -> 2 -> 3 -> 4 and you are given the third node with value 3, the linked list should become 1 -> 2 -> 4 after calling your function.

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

#include <stdlib.h>

#include "lib/list.h"

typedef struct ListNode* Position;
typedef struct ListNode* List;

void deleteNode(struct ListNode* node) {
  Position P;

  P = node -> next;
  node -> val = P -> val;
  node -> next = P -> next;
  free(P);
}

int main(int argc, char const *argv[])
{
  List L;
  Position P;
  int i;

  L = CreateList(15);
  PrintList(L);

  for (i = 5; i < 12; ++i)
  {
    P = Find(L, i);
    deleteNode(P);
    PrintList(L);
  }

  DestroyList(L);
  
  return 0;
}// A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.

// Return a deep copy of the list.

/**
 * Definition for singly-linked list with a random pointer.
 * struct RandomListNode {
 *     int label;
 *     struct RandomListNode *next;
 *     struct RandomListNode *random;
 * };
 */

#include <stdio.h>
#include <stdlib.h>

struct RandomListNode {
	int label;
  struct RandomListNode *next;
  struct RandomListNode *random;
};

typedef struct RandomListNode* Position;
typedef struct RandomListNode* List;

Position NewRandomListNode(int Value)
{
	Position P;

	P = malloc(sizeof(struct RandomListNode));
	P -> next = P -> random = NULL;
	P -> label = Value;

	return P;
}

List CloneRandomList(List L)
{
	Position P, NewNode;
	
	P = L;
	while (P != NULL)
	{
		NewNode = NewRandomListNode(P -> label);
		NewNode -> next = P -> next;
		P -> next = NewNode;
		P = P -> next -> next;
	}

	return L;
}

List ConnectRandPointer(List L)
{
	Position P;

	P = L;
	while (P != NULL)
	{
		if (P -> random == NULL)
			P -> next -> random = NULL;
		else
			P -> next -> random = P -> random -> next;
	
		P = P -> next -> next;
	}

	return L;
}

List DisconnectList(List L)
{
	Position P1, P2;
	List NewList;

	NewList = L -> next;
	P1 = L;
	P2 = NewList;

	while (P1 != NULL)
	{
		P1 -> next = P1 -> next -> next;
		if (P2 -> next != NULL)
			P2 -> next = P2 -> next -> next;
		else
			P2 -> next = NULL;

		P1 = P1 -> next;
		P2 = P2 -> next;
	}

	return NewList;
}

struct RandomListNode *copyRandomList(struct RandomListNode *head) {
	List L;

	if (head == NULL)
		return NULL;

	L = CloneRandomList(head);
	L = ConnectRandPointer(L);
	return DisconnectList(L);
}

void PrintList(List L)
{
  while (L != NULL)
  {
    printf("%d ", L -> label);
    L = L -> next;
  }

  printf("\n");
}

int main(int argc, char const *argv[])
{
	int i;
	List L, L2;
	Position P;

	L = NewRandomListNode(-1);
	P = L;
	for (i = 1; i < 0; ++i)
	{
		P -> next = NewRandomListNode(i);
		P = P -> next;		
	}

	PrintList(L);

	P = L;
	while (P != NULL)
	{
		if (P -> next)
			P -> random = P -> next -> next;
		else
			P -> random = NULL;

		P = P -> next;
	}

	L2 = copyRandomList(L);
	PrintList(L2);
	return 0;
}// Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.

// For example:
// Given the below binary tree and sum = 22,
//               5
//              / \
//             4   8
//            /   / \
//           11  13  4
//          /  \    / \
//         7    2  5   1
// return
// [
//    [5,4,11,2],
//    [5,8,4,5]
// ]

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *columnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */

#include <stdio.h>
#include <stdlib.h>

#include "lib/tree.h"

typedef struct TreeNode* Tree;
typedef struct TreeNode* Position;

#define SIZE 2
#define ElementType int

struct StackRecord
{
	int Size;
	int Capacity;
	ElementType* Next;
};

typedef struct StackRecord* Stack;

Stack Initialize() 
{
	Stack S;

	S = malloc(sizeof(struct StackRecord));
	S -> Size = 0;
	S -> Capacity = SIZE;
	S -> Next = malloc(sizeof(ElementType) * S -> Capacity);

	return S;
}

int IsFull(Stack S)
{
	return S -> Size == S -> Capacity;
}

int IsEmpty(Stack S)
{
	return S -> Size == 0;
}

ElementType Pop(Stack S)
{
	if (IsEmpty(S))
	{
		fprintf(stderr, "Empty Stack\n");
		exit(1);
	}

	return S -> Next[--S -> Size];
}

void Push(Stack S, ElementType X)
{
	if (IsFull(S))
	{
		S -> Next = realloc(S -> Next, S -> Capacity * 2 * sizeof(ElementType));
		S -> Capacity *= 2;
	}

	S -> Next[S -> Size++] = X;
}

void Destroy(Stack S)
{
	free(S -> Next);
	free(S);
}

struct PathSumRecord
{
	int* ColumnSizes;
	int Size;
	int Capacity;
	int** Next;
};

typedef struct PathSumRecord* PSR;

PSR InitializePSR()
{
	PSR P;

	P = malloc(sizeof(struct PathSumRecord));
	P -> Size = 0;
	P -> Capacity = SIZE;
	P -> ColumnSizes = malloc(sizeof(int) * P -> Capacity);
	P -> Next = malloc(sizeof(int*) * P -> Capacity);

	return P;
}

void AddValuesToPSR(PSR P, int* Values, int Size)
{
	if (P -> Capacity == P -> Size)
	{
		P -> Next = realloc(P -> Next, sizeof(int*) * 2 * P -> Capacity);
		P -> Capacity *= 2;
		P -> ColumnSizes = realloc(P -> ColumnSizes, sizeof(int*) * 2 * P -> Capacity);
	}

	int i;
	int* BUffer;

	BUffer = malloc(sizeof(int) * Size);
	for (i = 0; i < Size; ++i)
		BUffer[i] = Values[i];

	P -> Next[P -> Size] = BUffer;
	P -> ColumnSizes[P -> Size] = Size;
	++ P -> Size;
}

void PS(struct TreeNode* root, int sum, PSR P, Stack S) {
	if (root == NULL)
		return;

	if (root -> left == NULL && root -> right == NULL)
	{
		if (sum != root -> val)
			return;

		Push(S, root -> val);
		AddValuesToPSR(P, S -> Next, S -> Size);
		Pop(S);
		return;
	}

	Push(S, root -> val);

	if (root -> left)
		PS(root -> left, sum - root -> val, P, S);

	if (root -> right)
		PS(root -> right, sum - root -> val, P, S);

	Pop(S);
	return;	
}

int** pathSum(struct TreeNode* root, int sum, int** columnSizes, int* returnSize) {
	if (root == NULL)
	{
		*columnSizes = NULL;
		*returnSize == 0;
		return NULL;
	}

	PSR P;
	Stack S;

	P = InitializePSR();
	S = Initialize();

	PS(root, sum, P, S);

	if (P -> Size != 0)
	{
		*columnSizes = P -> ColumnSizes;
		*returnSize = P -> Size;
		return P -> Next;		
	}
	else
	{
		columnSizes = NULL;
		returnSize == 0;
		return NULL;
	}
}

int main(int argc, char const *argv[])
{
	Tree T;
	int **Buffer;
	int* ColumnSizes;
	int ReturnSize;
	int i, j;

	T = CreateTree();

	PreOrderTraverse(T);
	printf("\n");

	InOrderTraverse(T);
	printf("\n");

	PostOrderTraverse(T);
	printf("\n");

	Buffer = pathSum(T, 1, &ColumnSizes, &ReturnSize);
	for (i = 0; i < ReturnSize; ++i)
	{
		for (j = 0; j < ColumnSizes[i]; ++j)
			printf("%d ", Buffer[i][j]);		
		printf("\n");
	}

	return 0;
}// Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.

#include <stdio.h>
#include <stdlib.h>

#include "lib/list.h"

#define ElementType int
#define Prime 17

typedef struct ListNode* List;
typedef struct ListNode* Position;
typedef struct HashTbl* HashTable;

struct HashTbl
{
  int TableSize;
  List* TheLists;
};

Position NewListNode(int Value)
{
  Position P;

  P = malloc(sizeof(struct ListNode));
  P -> val = Value;
  P -> next = NULL;

  return P;
}

HashTable Initialize(int Capacity)
{
  HashTable HT;
  int i;

  HT = malloc(sizeof(struct HashTbl));
  HT -> TableSize = Capacity;
  HT -> TheLists = malloc(sizeof(Position) * Capacity);

  for (i = 0; i < Capacity; ++i)
  {
    HT -> TheLists[i] = NewListNode(-1);
  }

  return HT;
}

int Hash(int Value)
{
  while (Value < 0)
    Value += Prime;

  return Value % Prime;
}

// Position Find(HashTable HT, int Value)
// {
//  List L;
//  Position P;

//  L = HT -> TheLists[Hash(Value)];

//  P = L -> next;

//  for (; P != NULL; P = P -> next)
//  {
//    if (P -> val == Value)
//      return P;
//  }

//  return NULL;
// }

void Insert(HashTable HT, int Value)
{
  List L;
  Position P;

  L = HT -> TheLists[Hash(Value)];

  P = L -> next;

  for (; P != NULL; P = P -> next)
  {
    if (P -> val == Value)
      return;
  }
  
  P = NewListNode(Value);
  P -> next = L -> next;
  L -> next = P;  
}

int FindAndInsert(HashTable HT, int Value)
{
  List L;
  Position P;

  L = HT -> TheLists[Hash(Value)];

  P = L -> next;

  for (; P != NULL; P = P -> next)
  {
    if (P -> val == Value)
      return 1;
  }
  
  P = NewListNode(Value);
  P -> next = L -> next;
  L -> next = P;  
  return 0;
}

int containsDuplicate(int* nums, int numsSize) {
  if (nums == NULL || numsSize <= 1)
    return 0;

  int i;
  HashTable HT;

  HT = Initialize(Prime);
  for (i = 0; i < numsSize; ++i)
  {
    if (FindAndInsert(HT, nums[i]) == 1)
      return 1;
  }

  return 0;
}

int main(int argc, char const *argv[])
{
  int* Numbers;
  int Len, i;

  Len = 10;
  Numbers = malloc(sizeof(int) * Len);
  Numbers[0] = -100;

  for (i = 1; i < Len; ++i)
    Numbers[i] = i;

  printf("%d\n", containsDuplicate(Numbers, Len));
  return 0;
}// Given an array of integers, every element appears three times except for one. Find that single one.

// Note:
// Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?

#include <stdio.h>

#define BITS_LENGTH 64

int singleNumber(int* nums, int numsSize) {
	int Bits[BITS_LENGTH] = {0};
	int i, j, Number;

	for (i = 0; i < numsSize; ++i)
	{

		for (j = 0; j < BITS_LENGTH; ++j)
		{
			Bits[BITS_LENGTH - 1 - j] += (nums[i] & 0x01);
			nums[i] = nums[i] >> 1;

			if (nums[i] == 0)
				break;
		}
	}

	Number = 0;
	for (i = 0; i < BITS_LENGTH; ++i)
	{
		Number = Number << 1;
		if (Bits[i] % 3 != 0)
			Number |= 1;
	}

	return Number;
}

int main(int argc, char const *argv[])
{
	int Numbers[] = {0,0,0,5};
	printf("%d\n", singleNumber(Numbers, sizeof(Numbers) / sizeof(Numbers[0])));

	return 0;
}/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *columnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */

#include <stdio.h>
#include <stdlib.h>

#include "lib/tree.h"

typedef struct TreeNode* Tree;
typedef struct TreeNode* Position;

struct LevelTreeNode
{
  Position Node;
  int Level;
};

typedef struct LevelTreeNode* LevelTree;
typedef struct LevelTreeNode* LevelPosition;

LevelPosition NewLevelNode(Position P, int Level)
{
  LevelPosition LP;

  LP = malloc(sizeof(struct LevelTreeNode));
  LP -> Node = P;
  LP -> Level = Level;

  return LP;
}

#define ElementType LevelPosition
#define SIZE 2

struct QueueRecord
{
  int Front;
  int Rear;
  int Capacity;
  ElementType* Next;
};

typedef struct QueueRecord* Queue;

Queue InitializeQueue()
{
  Queue Q;

  Q = malloc(sizeof(struct QueueRecord));
  Q -> Front = Q -> Rear = 0;
  Q -> Capacity = SIZE;
  Q -> Next = malloc(sizeof(ElementType) * SIZE);

  return Q;
}

int Succ(Queue Q, int Index)
{
  if (++Index >= Q -> Capacity)
    return Index % Q -> Capacity;

  return Index;
}

int IsQueueEmpty(Queue Q)
{
  return Q -> Front == Q -> Rear;
}

int IsQueueFul(Queue Q)
{
  return Succ(Q, Q -> Rear) == Q -> Front;
}

ElementType Dequeue(Queue Q)
{
  if (IsQueueEmpty(Q))
  {
    fprintf(stderr, "Empty Queue\n");
    exit(1);
  }

  int i;
  i = Q -> Front;
  Q -> Front = Succ(Q, Q -> Front);
  return Q -> Next[i];
}

Queue Rearrange(Queue Q)
{
  ElementType* Buffer;
  int i;

  Buffer = malloc(sizeof(ElementType) * Q -> Capacity * 2);
  i = 0;
  while (!IsQueueEmpty(Q))
    Buffer[i++] = Dequeue(Q);

  Q -> Capacity *= 2;
  Q -> Front = 0;
  Q -> Rear = i;
  free(Q -> Next);
  Q -> Next = Buffer;

  return Q;
}

void Enqueue(Queue Q, ElementType X)
{
  if (IsQueueFul(Q))
    Q = Rearrange(Q);

  Q -> Next[Q -> Rear] = X;
  Q -> Rear = Succ(Q, Q -> Rear);
}

ElementType Front(Queue Q)
{
  if (IsQueueEmpty(Q))
  {
    fprintf(stderr, "Empty Queue\n");
    exit(1);    
  }

  return Q -> Next[Q -> Front];
}

struct ReturnValueRecord
{
  int X;
  int Y;
  int** Buffer;
  int* ColumnSizes;
  int* ColumnCapacity;
  int Capacity;
};

typedef struct ReturnValueRecord* RetValue;

RetValue InitializeRetValue()
{
  RetValue RV;
  int i;

  RV = malloc(sizeof(struct ReturnValueRecord));
  RV -> X = RV -> Y = 0;
  RV -> Capacity = SIZE;
  RV -> ColumnSizes = malloc(sizeof(int) * SIZE);
  RV -> ColumnCapacity = malloc(sizeof(int) * SIZE);
  for (i = 0; i < SIZE; ++i)
  {
    RV -> ColumnCapacity[i] = SIZE;
    RV -> ColumnSizes[i] = 0;
  } 

  RV -> Buffer = malloc(sizeof(int*) * SIZE);

  for (i = 0; i < SIZE; ++i)
    RV -> Buffer[i] = malloc(sizeof(int) * SIZE);

  return RV;
}

void PushToRetValue(RetValue RV, int Value)
{
  int i;

  if (RV -> Y >= RV -> Capacity)
  {
    RV -> ColumnSizes = realloc(RV -> ColumnSizes, RV -> Capacity * 2 * sizeof(int));
    RV -> ColumnCapacity = realloc(RV -> ColumnCapacity, RV -> Capacity * 2 * sizeof(int));
    RV -> Buffer = realloc(RV -> Buffer, RV -> Capacity * 2 * sizeof(int*));

    for (i = RV -> Y; i < RV -> Capacity * 2; ++i)
    {
      RV -> ColumnSizes[i] = 0;
      RV -> Buffer[i] = malloc(sizeof(int) * SIZE);
      RV -> ColumnCapacity[i] = SIZE;
    } 
  
    RV -> Capacity *= 2;
  }

  if (RV -> X >= RV -> ColumnCapacity[RV -> Y])
  {
    RV -> Buffer[RV -> Y] = realloc(RV -> Buffer[RV -> Y], sizeof(int) * RV -> ColumnCapacity[RV -> Y] * 2);
    RV -> ColumnCapacity[RV -> Y] *= 2;
  }

  (RV -> Buffer)[RV -> Y][RV -> X] = Value;
  ++ RV -> X;
  ++ RV -> ColumnSizes[RV -> Y];
}

void Reverse(int* Array, int Size)
{
  int i, j, Temp;

  i = 0;
  j = Size - 1;

  while (i < j)
  {
    Temp = Array[i];
    Array[i] = Array[j];
    Array[j] = Temp;

    ++i;
    --j;
  }
}

int** zigzagLevelOrder(struct TreeNode* root, int** columnSizes, int* returnSize) {
  RetValue RV;
  Queue Q;
  LevelPosition LP, FrontNode;

  if (root == NULL)
  {
    *columnSizes = 0;
    returnSize = 0;
    return NULL;
  }

  RV = InitializeRetValue();
  Q = InitializeQueue();
  Enqueue(Q, NewLevelNode(root, 0));

  while (!IsQueueEmpty(Q))
  {
    LP = Dequeue(Q);

    if (LP -> Node -> left)
      Enqueue(Q, NewLevelNode(LP -> Node -> left, LP -> Level + 1));
    if (LP -> Node -> right)
      Enqueue(Q, NewLevelNode(LP -> Node -> right, LP -> Level + 1));

    PushToRetValue(RV, LP -> Node -> val);


    if (IsQueueEmpty(Q) || LP -> Level != Front(Q) -> Level)
    {
      if (LP -> Level % 2 == 1)
      {
        Reverse(RV -> Buffer[RV -> Y], RV -> ColumnSizes[RV -> Y]);
      }

      ++ RV -> Y;
      RV -> X = 0;
    }
  }

  *columnSizes = RV -> ColumnSizes;
  *returnSize = RV -> Y;
  return RV -> Buffer;
}

int main(int argc, char const *argv[])
{
  Tree T;
  int ReturnSize;
  int *ColumnSizes;
  int** Buffer;
  int i, j;

  T = CreateTree();

  PreOrderTraverse(T);
  printf("\n");

  InOrderTraverse(T);
  printf("\n");

  PostOrderTraverse(T);
  printf("\n");

  Buffer = zigzagLevelOrder(T, &ColumnSizes, &ReturnSize);

  printf("ReturnSize = %d\n", ReturnSize);

  for (i = 0; i < ReturnSize; ++i)
    printf("%d ", ColumnSizes[i]);
  printf("\n");

  for (i = 0; i < ReturnSize; ++i)
  {
    for (j = 0; j < ColumnSizes[i]; ++j)
      printf("%d ", Buffer[i][j]);
    printf("\n");
  }
  return 0;
}

// Sort a linked list in O(n log n) time using constant space complexity.

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

#include <stdio.h>
#include <stdlib.h>

#include "lib/list.h"

typedef struct ListNode* Position;
typedef struct ListNode* List;

List Split(List L)
{
	if (L == NULL || L -> next == NULL)
		return L;

	Position P1, P2, P3;
	List L1;
	P1 = P2 = L;

	while (P1 != NULL)
	{
		if (P1 -> next == NULL)
			break;

		P1 = P1 -> next -> next;
		P3 = P2;
		P2 = P2 -> next;
	}

	L1 = P3 -> next;
	P3 -> next = NULL;
	return L1;
}

List MergeSortedList(List L1, List L2)
{
	if (L1 == NULL)
		return L2;

	if (L2 == NULL)
		return L1;

	Position P1, P2, P;
	List L;

	if (L1 -> val < L2 -> val)
	{
		L = L1;
		L1 = L1 -> next;		
	}
	else
	{
		L = L2;
		L2 = L2 -> next;		
	}

	P = L;
	while (L1 != NULL && L2 != NULL)
	{
		if (L1 -> val < L2 -> val)
		{
			P -> next = L1;
			L1 = L1 -> next;
			P = P -> next;
		}
		else
		{
			P -> next = L2;
			L2 = L2 -> next;
			P = P -> next;
		}
	}

	if (L1 != NULL)
		P -> next = L1;

	if (L2 != NULL)
		P -> next = L2;

	return L;
}

struct ListNode* sortList(struct ListNode* head) {
	if (head == NULL || head -> next == NULL)
		return head;

	List L;

	L = Split(head);
	head = sortList(head);
	L = sortList(L);

	return MergeSortedList(head, L);  
}

int main(int argc, char const *argv[])
{
  List L1, L2, L;

	L1 = CreateEvenList(1);
  L2 = CreateOddList(10);
  PrintList(L1);
  PrintList(L2);

  L = Split(L1);
  PrintList(L1);
  PrintList(L);
  L2 = MergeSortedList(L, L1);
	PrintList(L2);

	L1 = CreateRandList(1);
  PrintList(L1);
	L1 = sortList(L1);
  PrintList(L1);
	return 0;
}// Reverse bits of a given 32 bits unsigned integer.

// For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).

#include <stdio.h>

#define WORD_LENGTH 32

int reverseBits(int n) {
	if (n == 0)
		return 0;

	int Result, i;

	Result = 0;

	for (i = 0; i < WORD_LENGTH; ++i)
	{
		Result = (Result << 1) | (n & 0x01);
		n = n >> 1;
	}

	return Result;
}

int main(int argc, char const *argv[])
{
	int N;

	N = -2;
	// N = 2;
	printf("%d\n", reverseBits(N));
	return 0;
}// Reverse a singly linked list.

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

#include <stdio.h>

#include "lib/list.h"

typedef struct ListNode* Position;
typedef struct ListNode* List;

List ReverseListRecursively(List L, List* Head)
{
	if (L -> next == NULL)
	{
		*Head = L;
		return L;
	}	

	Position P;
	P = ReverseListRecursively(L -> next, Head);
	P -> next = L;
	P = P -> next;
	return P;
}

List ReverseList1(List L)
{
	List Head;
	L = ReverseListRecursively(L, &Head);
	L -> next = NULL;
	return Head;
}

List ReverseList2(List L)
{
	Position PtrCur, PtrPre, PtrNext;

	if (L -> next == NULL)
		return L;

	PtrPre = L;
	PtrCur = L -> next;
	PtrPre -> next = NULL;

	while (PtrCur != NULL)
	{
		PtrNext = PtrCur -> next;
		PtrCur -> next = PtrPre;
		PtrPre = PtrCur;
		PtrCur = PtrNext;
	}

	return PtrPre;
}

struct ListNode* reverseList(struct ListNode* head) {
	if (head == NULL)
		return NULL;

	if (rand() % 2 == 1)
		return ReverseList1(head);
	else
		return ReverseList2(head);
}

int main(int argc, char const *argv[])
{
	List L1, L2;

	L1 = CreateReversedList(15);
	PrintList(L1);

	L1 = reverseList(L1);
	PrintList(L1);
	return 0;
}// Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).

// For example, this binary tree is symmetric:

//     1
//    / \
//   2   2
//  / \ / \
// 3  4 4  3
// But the following is not:
//     1
//    / \
//   2   2
//    \   \
//    3    3

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

#include <stdio.h>
#include <stdlib.h>

#include "lib/tree.h"

typedef struct TreeNode* Tree;
typedef struct TreeNode* Position;

Tree InvertTree(Tree T)
{
	if (T == NULL)
		return NULL;

	if (T -> left == NULL && T -> right == NULL)
		return T;

	Tree Tmp;
	Tmp = T -> left;
	T -> left = T -> right;
	T -> right = Tmp;

	T -> left = InvertTree(T -> left);
	T -> right = InvertTree(T -> right);
	return T;
}

Tree CopyToTree(Tree T)
{
	if (T == NULL)
		return NULL;

	if (T -> left == NULL && T -> right == NULL)
		return NewNode(T -> val);

	Tree CT;
	CT = NewNode(T -> val);
	CT -> left = CopyToTree(T -> left);
	CT -> right = CopyToTree(T -> right);

	return CT;
}

bool IsSameTree(Tree T1, Tree T2)
{
	if (T1 == NULL && T2 == NULL)
		return true;

	if (T1 == NULL || T2 == NULL)
		return false;

	if (T1 -> val != T2 -> val)
		return false;

	return IsSameTree(T1 -> left, T2 -> left) && IsSameTree(T1 -> right, T2 -> right);
}

bool isSymmetric(struct TreeNode* root) {
	Tree T;
	bool IsSymmetric;
	T = CopyToTree(root);
	T = InvertTree(T);
	
	IsSymmetric = IsSameTree(root, T);
	MakeEmpty(T);

	return IsSymmetric;
}

int main(int argc, char const *argv[])
{
	Tree T, T2;

	T = CreateTree();
	PreOrderTraverse(T);
	printf("\n");

	InOrderTraverse(T);
	printf("\n");

	PostOrderTraverse(T);
	printf("\n");

	printf("%d\n", isSymmetric(T));
	return 0;
}

// Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.

// For example, 
// Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.

#include <stdio.h>
#include <stdlib.h>

#define ElementType int
#define MAX 8

struct StackRecord
{
	int Size;
	int Capacity;
	ElementType *Next;
};

typedef struct StackRecord * Stack;

Stack Initialize(int Capacity)
{
	Stack S;

	S = malloc(sizeof(struct StackRecord));
	S -> Size = 0;
	S -> Capacity = Capacity;
	S -> Next = malloc(sizeof(ElementType) * Capacity);

	return S;
}

int IsEmpty(Stack S)
{
	return S -> Size == 0;
}

int IsFull(Stack S)
{
	return S -> Capacity == S -> Size;
}

void Push(Stack S, ElementType Value)
{
	if (IsFull(S))
	{
		S -> Next = realloc(S -> Next, sizeof(ElementType) * S -> Capacity * 2);
		S -> Capacity *= 2;
	}

	S -> Next[S -> Size++] = Value;
}

ElementType Pop(Stack S)
{
	if (IsEmpty(S))
	{
		fprintf(stderr, "Empty Stack\n");
		exit(1);
	}

	return S -> Next[--S -> Size];
}

ElementType Top(Stack S)
{
	if (IsEmpty(S))
	{
		fprintf(stderr, "Empty Stack\n");
		exit(1);
	}

	return S -> Next[S -> Size - 1];
}

void Destroy(Stack S)
{
	free(S -> Next);
	free(S);
}

struct MaxStackRecord
{
	Stack S1, S2;
};

typedef struct MaxStackRecord* MaxStack;

MaxStack CreateMaxStack(int Capacity)
{
	MaxStack MS;

	MS = malloc(sizeof(struct MaxStackRecord));
	MS -> S1 = Initialize(Capacity);
	MS -> S2 = Initialize(Capacity);
	return MS;
}

void PushMaxStack(MaxStack MS, ElementType Value)
{
	ElementType MaxValue;

	if (IsEmpty(MS -> S1))
	{
		Push(MS -> S1, Value);
		Push(MS -> S2, Value);
		return;
	}

	MaxValue = Top(MS -> S2);
	if (MaxValue < Value)
		Push(MS -> S2, Value);
	else
		Push(MS -> S2, MaxValue);

	Push(MS -> S1, Value);
}

void PopMaxStack(MaxStack MS)
{
	Pop(MS -> S1);
	Pop(MS -> S2);
}

ElementType TopOfMaxStack(MaxStack MS)
{
	return Top(MS -> S1);
}

ElementType GetMaxValue(MaxStack MS)
{
	return Top(MS -> S2);
}

void DestroyMaxStack(MaxStack MS)
{
	Destroy(MS -> S1);
	Destroy(MS -> S2);
}

int trap(int* height, int heightSize) {
	if (heightSize <= 2)
		return 0;

	MaxStack MSLeft, MSRight;
	int i;
	int Bars, MaxRight, MaxLeft;

	MSLeft = CreateMaxStack(MAX);
	MSRight = CreateMaxStack(MAX);

	// PushMaxStack(MSLeft, height[0]);
	for (i = heightSize - 1; i >= 1; --i)
		PushMaxStack(MSRight, height[i]);

	Bars = 0;
	for (i = 1; i < heightSize - 1; ++i)
	{
		PushMaxStack(MSLeft, height[i-1]);
		PopMaxStack(MSRight);

		MaxLeft = GetMaxValue(MSLeft);
		MaxRight = GetMaxValue(MSRight);

		if (height[i] < MaxLeft && height[i] < MaxRight)
		{
			if (MaxRight < MaxLeft)
				Bars += MaxRight - height[i];
			else
				Bars += MaxLeft - height[i];
		}
	}

	return Bars;
}

int main(int argc, char const *argv[])
{
	int TrapNum[] = {0,1,0,2,1,0,1,3,2,1,2,1};
	// int TrapNum[] = {2,0,2};
	int Len;

	Len = sizeof(TrapNum) / sizeof(TrapNum[0]);

	printf("%d\n", trap(TrapNum, Len));
	return 0;
}// Given a linked list, determine if it has a cycle in it.

// Follow up:
// Can you solve it without using extra space?

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

#include <stdio.h>

#include "lib/list.h"

typedef struct ListNode* Position;
typedef struct ListNode* List;


int hasCycle(struct ListNode *head) {
  Position P1, P2;

  if (head == NULL)
    return 0;

  P1 = P2 = head;

  while (P1 != NULL)
  {
    P2 = P2 -> next;

    if (P1 -> next == NULL)
      return 0;

    P1 = P1 -> next -> next;

    if (P1 == P2)
      return 1;
  }

  return 0;
}

int main(int argc, char const *argv[])
{
  List L1, L2, L3;
  Position P;

  L1 = CreateList(1);
  PrintList(L1);
  printf("%d\n", hasCycle(L1));

  for (P = L1; P -> next != NULL; P = P -> next);
  P -> next = L1;
  printf("%d\n", hasCycle(L1));

  L2 = CreateList(5);
  PrintList(L2);
  printf("%d\n", hasCycle(L2));
  for (P = L2; P -> next != NULL; P = P -> next);
  P -> next = L2;
  printf("%d\n", hasCycle(L2));

  L3 = CreateList(2);
  PrintList(L3);
  printf("%d\n", hasCycle(L3));
  for (P = L3; P -> next != NULL; P = P -> next);
  P -> next = L3;
  printf("%d\n", hasCycle(L3));
  return 0;
}// Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

#include <stdio.h>
#include <stdlib.h>

#include "lib/list.h"

typedef struct ListNode* Position;
typedef struct ListNode* List;

List MergeSortedList(List L1, List L2)
{
  if (L1 == NULL)
    return L2;

  if (L2 == NULL)
    return L1;

  List NewList;
  Position P;

  if (L1 -> val > L2 -> val)
  {
    NewList = L2;
    L2 = L2 -> next;
  }
  else
  {
    NewList = L1;
    L1 = L1 -> next;
  }

  P = NewList;

  while (L1 != NULL && L2 != NULL)
  {
    if (L1 -> val > L2 -> val)
    {
      P -> next = L2;
      L2 = L2 -> next;
    }
    else
    {
      P -> next = L1;
      L1 = L1 -> next;
    }

    P = P -> next;
  }

  if (L1 != NULL)
    P -> next = L1;

  if (L2 != NULL)
    P -> next = L2;

  return NewList;
}

List MergeSortLists(List* L, int Size)
{
  if (Size == 0)
    return NULL;

  if (Size == 1)
    return *L;

  List L1, L2;
  L1 = MergeSortLists(L, Size / 2);
  L2 = MergeSortLists(L + Size / 2, Size - Size / 2);

  return MergeSortedList(L1, L2);
}

struct ListNode* mergeKLists(struct ListNode** lists, int listsSize) {
  if (lists == NULL || listsSize == 0)
    return NULL;

  return MergeSortLists(lists, listsSize);
}

int main(int argc, char const *argv[])
{
  List L1, L2, L3, L4, L;
  List* Lists;
  int Size;

  L1 = CreateEvenList(10);
  L2 = CreateOddList(10);
  L3 = CreateOddList(5);
  L4 = CreateEvenList(5);
  PrintList(L1);
  PrintList(L2);
  PrintList(L3);
  PrintList(L4);

  // L = MergeSortedList(L1, L2);
  // PrintList(L);

  Size = 4;
  Lists = malloc(sizeof(List) * Size);
  Lists[0] = L1;
  Lists[1] = L2;
  Lists[2] = L3;
  Lists[3] = L4;
  L = mergeKLists(Lists, Size);
  PrintList(L);
  return 0;
}// Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing all ones and return its area.

int maximalRectangle(char** matrix, int matrixRowSize, int matrixColSize) {
    
}// Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.

// You should preserve the original relative order of the nodes in each of the two partitions.

// For example,
// Given 1->4->3->2->5->2 and x = 3,
// return 1->2->2->4->3->5.

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

#include <stdio.h>
#include <stdlib.h>

#include "lib/list.h"

typedef struct ListNode* Position;
typedef struct ListNode* List;
typedef struct StackRecord* Stack;

#define ElementType Position

struct StackRecord
{
  int Size;
  int Capacity;
  ElementType* Next;
};

Stack Initialize(int Capacity)
{
  Stack S;

  S = malloc(sizeof(struct StackRecord));
  S -> Size = 0;
  S -> Capacity = Capacity;
  S -> Next = malloc(sizeof(ElementType) * Capacity);

  return S;
}

int IsFull(Stack S)
{
  return S -> Capacity == S -> Size;
}

int IsEmpty(Stack S)
{
  return S -> Size == 0;
}

void Push(Stack S, ElementType Value)
{
  if (IsFull(S))
  {
    S -> Next = realloc(S -> Next, S -> Capacity * 2 * sizeof(ElementType));
    S -> Capacity *= 2;
  }

  S -> Next[S -> Size++] = Value;
}

ElementType Pop(Stack S)
{
  if (IsEmpty(S))
  {
    fprintf(stderr, "Empty Stack\n");
    exit(1);
  }

  return S -> Next[--S -> Size];
}

void Destroy(Stack S)
{
  free(S -> Next);
  free(S);
}

void Swap(Position P1, Position P2)
{
  int Temp;

  Temp = P1 -> val;
  P1 -> val = P2 -> val;
  P2 -> val = Temp;
}

struct ListNode* partition2(struct ListNode* head, int x) {
  if (head == NULL)
    return NULL;

  Position P, P1, P2;
  Stack S;

  S = Initialize(16);
  P = head;
  while (P != NULL)
  {
    Push(S, P);
    P = P -> next;
  } 

  while (!IsEmpty(S))
  {
    P = Pop(S);

    if (P -> val >= x)
    {
      while (P -> next != NULL)
      {
        if (P -> next -> val < x)
        {
          Swap(P, P -> next);
          P = P -> next;
        } 
        else
        {
          break;
        }
      } 
    }
  }

  return head;
}

struct ListNode* partition(struct ListNode* head, int x) {
  if (head == NULL)
    return NULL;

  List FakeHead;
  Position P1, P2, P3;

  FakeHead = NewListNode(-1);
  FakeHead -> next = head;

  P1 = NULL;
  for (P2 = FakeHead; P2 != NULL && P2 -> next != NULL; )
  {
    if (P1 == NULL && P2 -> next -> val >= x)
    {
      P1 = P2;
    }
    if (P1 != NULL && P2 -> next -> val < x)
    {
      P3 =  P2 -> next -> next;
      P2 -> next -> next = P1 -> next;
      P1 -> next = P2 -> next;
      P2 -> next = P3;
      P1 = P1 -> next;
      continue;
    }

    P2 = P2 -> next;
  }

  P1 = FakeHead -> next;
  free(FakeHead);
  return P1;
}

int main(int argc, char const *argv[])
{
  List L1, L2;
  List Head1, Head2;
  Position P;

  L1 = CreateList(3);
  L2 = CreateReversedList(5);
  PrintList(L1);
  PrintList(L2);

  for (P = L1; P -> next != NULL; P = P -> next);
  // P -> next = NewListNode(10);
  // P = P -> next;
  P -> next = L2;
  PrintList(L1);

  L1 = partition(L1, 2);
  PrintList(L1);
  return 0;
}// Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

// push(x) -- Push element x onto stack.
// pop() -- Removes the element on top of the stack.
// top() -- Get the top element.
// getMin() -- Retrieve the minimum element in the stack.

#include <stdio.h>
#include <stdlib.h>

#include "lib/test_stack.h"

#define ElementType int

struct StackRecord 
{
	int Size;
	int Capacity;
	ElementType* Next;
};

typedef struct StackRecord* Stack;

Stack Initialize(int Capacity)
{
	Stack S;

	S = malloc(sizeof(struct StackRecord));
	S -> Size = 0;
	S -> Capacity = Capacity;
	S -> Next = malloc(sizeof(ElementType) * Capacity);

	return S;
}

int IsEmpty(Stack S)
{
	return S -> Size == 0;
}

int IsFull(Stack S)
{
	return S -> Size == S -> Capacity;
}

void Push(Stack S, ElementType Value)
{
	if (IsFull(S))
	{
		S -> Next = realloc(S -> Next, sizeof(ElementType) * S -> Capacity * 2);
		S -> Capacity *= 2;
	}

	S -> Next[S -> Size++] = Value;
}

ElementType Pop(Stack S)
{
	if (IsEmpty(S))
	{
		fprintf(stderr, "Empty Stack\n");
		exit(1);
	}

	return S -> Next[--S -> Size];
}

ElementType Top(Stack S)
{
	if (IsEmpty(S))
	{
		fprintf(stderr, "Empty Stack\n");
		exit(1);
	}

	return S -> Next[S -> Size - 1];
}

void Destroy(Stack S)
{
	free(S -> Next);
	free(S);
}

typedef struct {
  Stack S1, S2;  
} MinStack;

void minStackCreate(MinStack *stack, int maxSize) {
	stack -> S1 = Initialize(maxSize);
	stack -> S2 = Initialize(maxSize);
}

void minStackPush(MinStack *stack, int element) {
	int Min;

	Push(stack -> S1, element);

	if (IsEmpty(stack -> S2))
		Push(stack -> S2, element);
	else
	{
		Min = Top(stack -> S2);
		if (Min > element)
			Push(stack -> S2, element);
		else
			Push(stack -> S2, Min);
	}
}

void minStackPop(MinStack *stack) {
	Pop(stack -> S1);
	Pop(stack -> S2);
}

int minStackTop(MinStack *stack) {
	Top(stack -> S1);
}

int minStackGetMin(MinStack *stack) {
	Top(stack -> S2);
}

void minStackDestroy(MinStack *stack) {
	Destroy(stack -> S1);
	Destroy(stack -> S2);
}

int main(int argc, char const *argv[])
{
	int i, Value, Min;
	MinStack* stack;
	
	stack = malloc(sizeof(MinStack));
	minStackCreate(stack, 2);

	for (i = 0; i < 10; ++i)
		minStackPush(stack, rand() % 20);

	for (i = 0; i < 10; ++i)
	{
		Value = minStackTop(stack);
		Min = minStackGetMin(stack);
		printf("%d %d\n", Value, Min);
		minStackPop(stack);
	}

	printf("At last, %d, %d\n", IsEmpty(stack -> S1), IsEmpty(stack -> S2));
	return 0;
}// Implement the following operations of a stack using queues.

// push(x) -- Push element x onto stack.
// pop() -- Removes the element on top of the stack.
// top() -- Get the top element.
// empty() -- Return whether the stack is empty.
// Notes:
// You must use only standard operations of a queue -- which means only push to back, peek/pop from front, size, and is empty operations are valid.
// Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.
// You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).

#include <stdio.h>
#include <stdlib.h>

#define ElementType int

struct QueueRecord
{
	int Capacity;
	int Front;
	int Rear;
	int Size;
	ElementType* Next;
};

typedef struct QueueRecord* Queue;

Queue Initialize(int Capacity)
{
	Queue Q;

	Q = malloc(sizeof(struct QueueRecord));
	Q -> Capacity = Capacity;
	Q -> Front = 0;
	Q -> Rear = 0;
	Q -> Next = malloc(sizeof(ElementType) * Q -> Capacity);
	Q -> Size = 0;

	return Q;
}

int Size(Queue Q)
{
	return Q -> Size;
}

int Succ(Queue Q, int Index)
{
	if (++Index >= Q -> Capacity)
		return Index % Q -> Capacity;

	return Index;
}

int IsEmpty(Queue Q)
{
	return Q -> Front == Q -> Rear;
}

int IsFull(Queue Q)
{
	return Succ(Q, Q -> Rear) == Q -> Front;
}

ElementType Dequeue(Queue Q)
{
	if (IsEmpty(Q))
	{
		fprintf(stderr, "Empty Queue\n");
		exit(1);
	}

	int Index;
	-- Q -> Size;
	Index = Q -> Front;
	Q -> Front = Succ(Q, Q -> Front);
	return Q -> Next[Index];
}

ElementType Front(Queue Q)
{
	if (IsEmpty(Q))
	{
		fprintf(stderr, "Empty Queue\n");
		exit(1);
	}

	return Q -> Next[Q -> Front];
}

Queue Rearrange(Queue Q)
{
	ElementType* Buffer = malloc(sizeof(ElementType) * Q -> Capacity * 2);
	int i;

	i = 0;
	while (!IsEmpty(Q))
		Buffer[i++] = Dequeue(Q);

	Q -> Capacity *= 2;
	Q -> Front = 0;
	Q -> Rear = i;
	free(Q -> Next);
	Q -> Next = Buffer;
	Q -> Size = i;

	return Q;
}

void Enqueue(Queue Q, ElementType Value)
{
	if (IsFull(Q))
		Q = Rearrange(Q);

	++ Q -> Size;
	Q -> Next[Q -> Rear] = Value;
	Q -> Rear = Succ(Q, Q -> Rear);
}

void Destroy(Queue Q)
{
	free(Q -> Next);
	free(Q);
}

struct Stack {
  Queue Q1, Q2;	
};

typedef struct {
  Queue Q1, Q2;
} Stack;

/* Create a stack */
void stackCreate(Stack *stack, int maxSize) {
	stack -> Q1 = Initialize(maxSize);
	stack -> Q2 = Initialize(maxSize);
}

Queue getQueueWithData(Stack *stack)
{
	if (IsEmpty(stack -> Q1))
		return stack -> Q2;
	else
		return stack -> Q1;
}

/* Push element x onto stack */
void stackPush(Stack *stack, int element) {
	Enqueue(getQueueWithData(stack), element);
}

/* Removes the element on top of the stack */
void stackPop(Stack *stack) {
	if (IsEmpty(stack -> Q1))
	{
		while (Size(stack -> Q2) != 1)
		{
			Enqueue(stack -> Q1, Dequeue(stack -> Q2));
		}

		Dequeue(stack -> Q2);
	}
	else
	{
		while (Size(stack -> Q1) != 1)
		{
			Enqueue(stack -> Q2, Dequeue(stack -> Q1));
		}

		Dequeue(stack -> Q1);
	}
}

/* Get the top element */
int stackTop(Stack *stack) {
	ElementType Value;

	if (IsEmpty(stack -> Q1))
	{
		while (Size(stack -> Q2) != 1)
		{
			Enqueue(stack -> Q1, Dequeue(stack -> Q2));
		}

		Value = Front(stack -> Q2);
		Enqueue(stack -> Q1, Dequeue(stack -> Q2));
	}
	else
	{
		while (Size(stack -> Q1) != 1)
		{
			Enqueue(stack -> Q2, Dequeue(stack -> Q1));
		}

		Value = Front(stack -> Q1);
		Enqueue(stack -> Q2, Dequeue(stack -> Q1));
	}

	return Value;
}

/* Return whether the stack is empty */
int stackEmpty(Stack *stack) {
	return IsEmpty(stack -> Q1) && IsEmpty(stack -> Q2);
}

/* Destroy the stack */
void stackDestroy(Stack *stack) {
	Destroy(stack -> Q1);
	Destroy(stack -> Q2);   
}

int TestStack()
{
 Stack* S;
 int i;

 S = malloc(sizeof(struct Stack));
 stackCreate(S, 2);

 for (i = 0; i < 100; ++i)
   stackPush(S, i);

 while (!stackEmpty(S))
 {
   printf("%d ", stackTop(S));
   stackPop(S); 	
 }

 printf("\n");

 stackDestroy(S);
}


int main(int argc, char const *argv[])
{
	TestStack();
	return 0;
}// Reverse a linked list from position m to n. Do it in-place and in one-pass.

// For example:
// Given 1->2->3->4->5->NULL, m = 2 and n = 4,

// return 1->4->3->2->5->NULL.

// Note:
// Given m, n satisfy the following condition:
// 1 ≤ m ≤ n ≤ length of list.

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

#include <stdio.h>
#include <stdlib.h>

#include "lib/list.h"

typedef struct ListNode* Position;
typedef struct ListNode* List;

struct ListNode* reverseBetween(struct ListNode* head, int m, int n) {
  if (head == NULL || head -> next == NULL)
    return head;

  if (m == n)
    return head;

  int i;
  Position PtrPre, PtrCur, PtrNext;
  Position PtrBegin, PtrEnd;
  Position PtrSubBegin, PtrSubEnd;

  i = 1;
  PtrPre = head;

  while (i < m)
  {
    PtrBegin = PtrPre;
    PtrPre = PtrPre -> next;
    ++i;
  }

  PtrSubBegin = PtrPre;
  PtrCur = PtrPre -> next;
  while (i < n)
  {
    PtrNext = PtrCur -> next;
    PtrCur -> next = PtrPre;
    PtrPre = PtrCur;
    PtrCur = PtrNext;
    ++i;
  }

  PtrSubEnd = PtrPre;
  PtrEnd = PtrCur;

  if (m != 1)
    PtrBegin -> next = PtrSubEnd;
  else
    head = PtrSubEnd;
  
  PtrSubBegin -> next = PtrEnd;

  return head;
}

int main(int argc, char const *argv[])
{
  List L1, L2, L;

  L1 = CreateEvenList(1);
  L2 = CreateOddList(10);
  PrintList(L1);
  PrintList(L2);

  L1 = reverseBetween(L1, 1, 2);
  // L = mergeTwoLists(L1, L2);
  PrintList(L1);
  return 0;
}// Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

// The brackets must close in the correct order, "()" and "()[]{}" are all valid but "(]" and "([)]" are not.

#include <stdio.h>
#include <stdlib.h>

#define ElementType char
#define MAX 2

struct StackRecord 
{
	int Size;
	int Capacity;
	ElementType* Next;
};

typedef struct StackRecord* Stack;

Stack Initialize(int Capacity)
{
	Stack S;

	S = malloc(sizeof(struct StackRecord));
	S -> Size = 0;
	S -> Capacity = Capacity;
	S -> Next = malloc(sizeof(ElementType) * Capacity);

	return S;
}

int IsEmpty(Stack S)
{
	return S -> Size == 0;
}

int IsFull(Stack S)
{
	return S -> Size == S -> Capacity;
}

void Push(Stack S, ElementType Value)
{
	if (IsFull(S))
	{
		S -> Next = realloc(S -> Next, sizeof(ElementType) * S -> Capacity * 2);
		S -> Capacity *= 2;
	}

	S -> Next[S -> Size++] = Value;
}

ElementType Pop(Stack S)
{
	if (IsEmpty(S))
	{
		fprintf(stderr, "Empty Stack\n");
		exit(1);
	}

	return S -> Next[-- S -> Size];
}

ElementType Top(Stack S)
{
	if (IsEmpty(S))
	{
		fprintf(stderr, "Empty Stack\n");
		exit(1);
	}

	return S -> Next[S -> Size - 1];
}

void Destroy(Stack S)
{
	free(S -> Next);
	free(S);
}

int IsPair(char c1, char c2)
{
	if ((c1 == '{' && c2 == '}') || (c1 == '(' && c2 == ')') || (c1 == '[' && c2 == ']'))
		return 1;
	
	return 0;
}

int IsLeftPart(char c)
{
	if ((c == '(') || (c == '{') || (c == '['))
		return 1;

	return 0;
}

int isValid(char* s) {
	char* Ptr;
	Stack S;

	S = Initialize(MAX);
	Ptr = s;
	while (*Ptr != '\0')
	{
		if (IsEmpty(S))
		{
			Push(S, *Ptr);			
		}
		else
		{
			if (IsLeftPart(*Ptr))
			{
					Push(S, *Ptr);
			}
			else
			{
				if (IsPair(Top(S), *Ptr))
					Pop(S);
				else
					return 0;
			}
		}

		++Ptr;
	}

	if (IsEmpty(S))
		return 1;
	else
		return 0;
}

int main(int argc, char const *argv[])
{
	printf("%d\n", isValid("()"));
	printf("%d\n", isValid("()[]{}"));
	printf("%d\n", isValid("([)]"));
	printf("%d\n", isValid("(]"));
	return 0;
}// Implement the following operations of a queue using stacks.

// push(x) -- Push element x to the back of queue.
// pop() -- Removes the element from in front of queue.
// peek() -- Get the front element.
// empty() -- Return whether the queue is empty.
// Notes:
// You must use only standard operations of a stack -- which means only push to top, peek/pop from top, size, and is empty operations are valid.
// Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.
// You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).

#include <stdio.h>
#include <stdlib.h>

#define ElementType int

struct StackRecord 
{
	int Size;
	int Capacity;
	ElementType *Next;
};

typedef struct StackRecord* Stack;

Stack Initialize(int Capacity)
{
	Stack S;

	S = malloc(sizeof(struct StackRecord));
	S -> Size = 0;
	S -> Capacity = Capacity;
	S -> Next = malloc(sizeof(ElementType) * S -> Capacity);

	return S;
}

int IsEmpty(Stack S)
{
	return S -> Size == 0;
}

int IsFull(Stack S)
{
	return S -> Size == S -> Capacity;
}

void Push(Stack S, ElementType Value)
{
	if (IsFull(S))
	{
		S -> Next = realloc(S -> Next, sizeof(ElementType) * S -> Capacity * 2);
		S -> Capacity *= 2;
	}

	S -> Next[S -> Size++] = Value;
}

ElementType Pop(Stack S)
{
	if (IsEmpty(S))
	{
		fprintf(stderr, "Empty Stack\n");
		exit(1);
	}

	return S -> Next[--S -> Size];
}

ElementType Top(Stack S)
{
	if (IsEmpty(S))
	{
		fprintf(stderr, "Empty Stack\n");
		exit(1);
	}

	return S -> Next[S -> Size - 1];
}

void Destroy(Stack S)
{
	free(S -> Next);
	free(S);
}

struct Queue {
	Stack S1, S2;
};

typedef struct {
	Stack S1, S2;    
} Queue;

/* Create a queue */
void queueCreate(Queue *queue, int maxSize) {
	queue -> S1 = Initialize(maxSize);	
	queue -> S2 = Initialize(maxSize);	
}

/* Push element x to the back of queue */
void queuePush(Queue *queue, int element) {
	Push(queue -> S1, element); 
}

void adjustQueue(Queue* queue)
{
	while (!IsEmpty(queue -> S1))
	{
		Push(queue -> S2, Pop(queue -> S1));
	}
}

/* Removes the element from front of queue */
void queuePop(Queue *queue) {
	if (IsEmpty(queue -> S2))
		adjustQueue(queue);

	Pop(queue -> S2);
}

/* Get the front element */
int queuePeek(Queue *queue) {
	if (IsEmpty(queue -> S2))
		adjustQueue(queue);

	Top(queue -> S2);
}

/* Return whether the queue is empty */
int queueEmpty(Queue *queue) {
	return IsEmpty(queue -> S1) && IsEmpty(queue -> S2);
}

/* Destroy the queue */
void queueDestroy(Queue *queue) {
	Destroy(queue -> S1);
	Destroy(queue -> S2);
}

int TestQueue()
{
 Queue* Q;
 int i;

 Q = malloc(sizeof(struct Queue));
 
 queueCreate(Q, 10);
 for (i = 0; i < 100; ++i)
   queuePush(Q, i);

 while (!queueEmpty(Q))
 {
 	 printf("%d ", queuePeek(Q));
   queuePop(Q);
 }
  
 printf("\n");

 queueDestroy(Q);
}

int main(int argc, char const *argv[])
{
	TestQueue();	
	return 0;
}// Given a linked list, swap every two adjacent nodes and return its head.

// For example,
// Given 1->2->3->4, you should return the list as 2->1->4->3.

// Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.


/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

#include <stdio.h>
#include <stdlib.h>

#include "lib/list.h"

typedef struct ListNode* Position;
typedef struct ListNode* List;

struct ListNode* swapPairs(struct ListNode* head) {
	if (head == NULL || head -> next == NULL)
		return head;

	Position P1, P2, P3;
	P1 = head;
	head = head -> next;
	P2 = head -> next;
	head -> next = P1;
	P1 -> next = P2;

	while (P2 != NULL && P2 -> next != NULL)
	{
		P3 = P2 -> next;
		P2 -> next = P3 -> next;
		P1 -> next = P3;
		P3 -> next = P2;

		P1 = P2;
		P2 = P1 -> next;
	}

	return head;
}

int main(int argc, char const *argv[])
{
  List L1, L2, L;

	L1 = CreateEvenList(1);
  L2 = CreateOddList(10);
  PrintList(L1);
  PrintList(L2);

  L1 = swapPairs(L1);
  PrintList(L1);

  L2 = swapPairs(L2);
  PrintList(L2);
	return 0;
}/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

#include <stdio.h>
#include <stdlib.h>
#include "lib/tree.h"

typedef struct TreeNode* Tree;
typedef struct TreeNode* Position;

struct TreeNode* invertTree(struct TreeNode* root) {
    if (root == NULL)
      return NULL;

    Tree T;

    T = root -> right;
    root -> right = root -> left;
    root -> left = T;

    invertTree(root -> left);
    invertTree(root -> right);

    return root;
}

int main(int argc, char const *argv[])
{
  Tree T;

  T = CreateTree();

  PreOrderTraverse(T);
  printf("\n");

  InOrderTraverse(T);
  printf("\n");

  PostOrderTraverse(T);
  printf("\n");

  T = invertTree(T);

  PreOrderTraverse(T);
  printf("\n");

  InOrderTraverse(T);
  printf("\n");

  PostOrderTraverse(T);
  printf("\n");

  return 0;
}// Given a list, rotate the list to the right by k places, where k is non-negative.

// For example:
// Given 1->2->3->4->5->NULL and k = 2,
// return 4->5->1->2->3->NULL.

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

#include <stdio.h>
#include <stdlib.h>

#include "lib/list.h"

typedef struct ListNode* Position;
typedef struct ListNode* List;

List ReverseList(List Head)
{
	Position P1, P2, P3;

	P1 = Head;
	P2 = Head -> next;
	P1 -> next = NULL;

	while (P2 != NULL)
	{
		P3 = P2 -> next;
		P2 -> next = P1;

		P1 = P2;
		P2 = P3;
	}

	return P1;
}

List RotateWithPosition(List head, int k)
{
	Position P1, P2, P3, P4;
	int i;

	P1 = head;
	for (i  = 0; i < k && P1 != NULL; ++i)
		P1 = P1 -> next;

	P2 = head;

	if (k > i)
		return ReverseList(head);

	if (k == i && P1 == NULL)
		return head;

	while (P1 != NULL)
	{
		P3 = P1;
		P4 = P2;

		P1 = P1 -> next;
		P2 = P2 -> next;
	}

	P4 -> next = NULL;
	P3 -> next = head;

	return P2;
}

int GetLengthOfList(List L)
{
	if (L == NULL)
		return 0;

	int i;

	i = 0;
	while (L != NULL)
	{
		L = L -> next;
		++i;
	}

	return i;
}

struct ListNode* rotateRight(struct ListNode* head, int k) {
	if (head == NULL || head -> next == NULL || k <= 0)
		return head;

	int Len;

	Len = GetLengthOfList(head);

	return RotateWithPosition(head, k % Len == 0 ? Len : k % Len);
}

int main(int argc, char const *argv[])
{
  List L1, L2, L;

	L1 = CreateList(1);
  PrintList(L1);

  L1 = rotateRight(L1, 2);
  PrintList(L1);

  // L2 = ReverseList(L2);
  // PrintList(L2);
	return 0;
}// Design a data structure that supports the following two operations:

// void addWord(word)
// bool search(word)
// search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.

// For example:

// addWord("bad")
// addWord("dad")
// addWord("mad")
// search("pad") -> false
// search("bad") -> true
// search(".ad") -> true
// search("b..") -> true

// Your WordDictionary object will be instantiated and called as such:
// struct WordDictionary* wordDictionary = wordDictionaryCreate();
// addWord(wordDictionary, "word");
// search(wordDictionary, "pattern");
// wordDictionaryFree(wordDictionary);

#include <stdio.h>
#include <stdlib.h>

#define ElementType char
typedef struct TrieNode* TrieTree;

struct TrieNode
{
	ElementType Value;
	int Tag;
	TrieTree Left, Right, Middle;
};

struct WordDictionary {
	TrieTree DicTree;
};


typedef struct WordDictionary* WDict;
/** Initialize your data structure here. */
struct WordDictionary* wordDictionaryCreate() {
	WDict WD;

	WD = malloc(sizeof(struct WordDictionary));
	WD -> DicTree = NULL;

	return WD;
}

TrieTree NewTrieNode(ElementType Value)
{
	TrieTree Tree;

	Tree = malloc(sizeof(struct TrieNode));
	Tree -> Value = Value;
	Tree -> Left = Tree -> Right = Tree -> Middle = NULL;
	Tree -> Tag = 0;

	return Tree;
}

TrieTree AddTrieTree(TrieTree Tree, char* Word, int k)
{
	if (Tree == NULL)
		Tree = NewTrieNode(Word[k]);

	if (Tree -> Value < Word[k])
		Tree -> Right = AddTrieTree(Tree -> Right, Word, k);
	else if (Tree -> Value > Word[k])
		Tree -> Left = AddTrieTree(Tree -> Left, Word, k);
	else
	{
		if (Word[k + 1] == '\0')
			Tree -> Tag = 1;
		else
			Tree -> Middle = AddTrieTree(Tree -> Middle, Word, k + 1);
	}

	return Tree;
}

/** Inserts a word into the data structure. */
void addWord(struct WordDictionary* wordDictionary, char* word) {
	wordDictionary -> DicTree = AddTrieTree(wordDictionary -> DicTree, word, 0);
}

int SearchTrieTree(TrieTree Tree, char* Word, int k)
{
	int Result = 0;
	if (Tree == NULL)
		return 0;

	if (Word[k] == '.' || Tree -> Value > Word[k])
		Result = SearchTrieTree(Tree -> Left, Word, k);

	if ((!Result) && (Word[k] == '.' || Tree -> Value < Word[k]))
		Result = SearchTrieTree(Tree -> Right, Word, k);
	
	if ((!Result) && (Word[k] == '.' || Tree -> Value == Word[k]))
	{
		if (Word[k + 1] == '\0' && Tree -> Tag == 1)
			Result = 1;
		else
			Result = SearchTrieTree(Tree -> Middle, Word, k + 1);
	}

	return Result;
}
/** Returns if the word is in the data structure. A word could
    contain the dot character '.' to represent any one letter. */
int search(struct WordDictionary* wordDictionary, char* word) {
	return SearchTrieTree(wordDictionary -> DicTree, word, 0);
}

void FreeTrieTree(TrieTree Tree)
{
	if (Tree != NULL)
	{
		if (Tree -> Left != NULL)
			FreeTrieTree(Tree -> Left);
		if (Tree -> Right != NULL)
			FreeTrieTree(Tree -> Right);
		if (Tree -> Middle != NULL)
			FreeTrieTree(Tree -> Middle);

		free(Tree);
	}
}

/** Deallocates memory previously allocated for the data structure. */
void wordDictionaryFree(struct WordDictionary* wordDictionary) {
	FreeTrieTree(wordDictionary -> DicTree);
	free(wordDictionary);
}

// addWord("bad")
// addWord("dad")
// addWord("mad")
// search("pad") -> false
// search("bad") -> true
// search(".ad") -> true
// search("b..") -> true

// Your WordDictionary object will be instantiated and called as such:
// struct WordDictionary* wordDictionary = wordDictionaryCreate();
// addWord(wordDictionary, "word");
// search(wordDictionary, "pattern");
// wordDictionaryFree(wordDictionary);

int main(int argc, char const *argv[])
{
	struct WordDictionary* wd = wordDictionaryCreate();
	// addWord(wd, "word");
	// printf("%d\n", search(wd, "pattern")); 
	// wordDictionaryFree(wd);

	addWord(wd, "a");
	// addWord(wd, "dad");
	// addWord(wd, "mad");

	printf("%d\n", search(wd, ".")); 
	// printf("%d\n", search(wd, "z*d")); 
	// printf("%d\n", search(wd, "a")); 

	wordDictionaryFree(wd);
	// 	search("pad") 
	// search("bad") 
	// search(".ad") 
	// search("b..")
	return 0;
}/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

#include <stdio.h>
#include <stdlib.h>
#include "lib/tree.h"

typedef struct TreeNode* Tree;
typedef struct TreeNode* Position;

int Max(int a, int b)
{
	return a > b ? a : b;
}

int maxDepth(struct TreeNode* root) {
	if (root == NULL)
		return 0;

	if (root -> left == NULL && root -> right == NULL)
		return 1;

	int leftDepth, rightDepth;

	leftDepth = maxDepth(root -> left);
	rightDepth = maxDepth(root -> right);

	return Max(leftDepth, rightDepth) + 1;
}

int main(int argc, char const *argv[])
{
	Tree T;
	int Depth;

	T = CreateTree();

	PreOrderTraverse(T);
	printf("\n");

	InOrderTraverse(T);
	printf("\n");

	PostOrderTraverse(T);
	printf("\n");

	Depth = maxDepth(T);
	printf("%d\n", Depth);
	return 0;
}// Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.

// If the fractional part is repeating, enclose the repeating part in parentheses.

// For example,

// Given numerator = 1, denominator = 2, return "0.5".
// Given numerator = 2, denominator = 1, return "2".
// Given numerator = 2, denominator = 3, return "0.(6)".

// Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.

// If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.

// You may not alter the values in the nodes, only nodes itself may be changed.

// Only constant memory is allowed.

// For example,
// Given this linked list: 1->2->3->4->5

// For k = 2, you should return: 2->1->4->3->5

// For k = 3, you should return: 3->2->1->4->5

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
#include <stdio.h>
#include <stdlib.h>

#include "lib/list.h"

typedef struct ListNode* Position;
typedef struct ListNode* List;

int GetLengthOfList(List L)
{
  int i;

  i = 0;
  while (L != NULL)
  {
    L = L -> next;
    ++i;
  }

  return i;
}

struct ListNode* reverseKGroup(struct ListNode* head, int k) {
  if (k <= 1 || head == NULL || head -> next == NULL)
    return head;

  int RoundOfReverse, Len;
  int i, j;
  List NewList;
  Position PtrBeforeEnd, PtrSubBegin, PtrPre, PtrCur, PtrNext;

  Len = GetLengthOfList(head);

  if (Len < k)
    return head;

  RoundOfReverse = Len / k;
  PtrPre = head;
  PtrCur = head -> next;

  for (i = 0; i < RoundOfReverse; ++i)
  {
    PtrSubBegin = PtrPre;
    for (j = 1; j < k; ++j)
    {
      PtrNext = PtrCur -> next;
      PtrCur -> next = PtrPre;
      PtrPre = PtrCur;
      PtrCur = PtrNext;
    }

    if (i == 0)
      NewList = PtrPre;
    else
    {
      PtrBeforeEnd -> next = PtrPre;
    }

    PtrSubBegin -> next = PtrCur;
    PtrBeforeEnd = PtrSubBegin;

    PtrPre = PtrCur;
    if (PtrCur != NULL)
      PtrCur = PtrCur -> next;
  }

  return NewList;
}

int main(int argc, char const *argv[])
{
  List L1;

  L1 = CreateEvenList(3);
  PrintList(L1);

  L1 = reverseKGroup(L1, 2);
  PrintList(L1);
  return 0;
}// Implement a trie with insert, search, and startsWith methods.
// Note:
// You may assume that all inputs are consist of lowercase letters a-z.

// Your Trie object will be instantiated and called as such:
// struct TrieNode* node = trieCreate();
// insert(node, "somestring");
// search(node, "key");
// trieFree(node);

#include <stdio.h>
#include <stdlib.h>

#define ElementType char

typedef struct TrieNode* TNode;

struct TrieNode {
	ElementType Value;
	TNode Left, Right, Middle;
	int Tag;
};

TNode NewNode(ElementType Value)
{
	TNode Node;

	Node = malloc(sizeof(struct TrieNode));
	Node -> Left = Node -> Right = Node -> Middle = NULL;
	Node -> Value = Value;
	Node -> Tag = 0;
	return Node;
}

/** Initialize your data structure here. */
struct TrieNode* trieCreate() {
	return NewNode('a');
}

TNode TrieInsert(TNode root, char* word, int k)
{
	if (root == NULL && word[k] != '\0')
		root = NewNode(word[k]);
	// if (word[k] == '\0')
	// 	return;

	if (root -> Value > word[k])
		root -> Left = TrieInsert(root -> Left, word, k);
	else if (root -> Value < word[k])
		root -> Right = TrieInsert(root -> Right, word, k);
	else
	{
		if (word[k + 1] == '\0')
			root -> Tag = 1;
		else
			root -> Middle = TrieInsert(root -> Middle, word, k + 1);			
	}

	return root;
}
/** Inserts a word into the trie. */
void insert(struct TrieNode* root, char* word) {
	root -> Middle = TrieInsert(root -> Middle, word, 0);
}

int TrieSearch(TNode root, char* word, int k)
{
	if (root == NULL)
		return 0;

	if (root -> Value > word[k])
		return TrieSearch(root -> Left, word, k);
	else if (root -> Value < word[k])
		return TrieSearch(root -> Right, word, k);
	else
	{
		if (word[k + 1] == '\0')
		{
			if (root -> Tag == 1)
				return 1;
			else
				return 0;
		}
		else
			return TrieSearch(root -> Middle, word, k + 1);			
	}
}

/** Returns if the word is in the trie. */
int search(struct TrieNode* root, char* word) {
	return TrieSearch(root -> Middle, word, 0);
}

int TrieStartWith(struct TrieNode* root, char* prefix, int k) {
	if (prefix[k] == '\0')
		return 1;
	if (root == NULL)
		return 0;

	if (root -> Value > prefix[k])
		return TrieStartWith(root -> Left, prefix, k);
	else if (root -> Value < prefix[k])
		return TrieStartWith(root -> Right, prefix, k);
	else
		return TrieStartWith(root -> Middle, prefix, k + 1);
}
/** Returns if there is any word in the trie 
    that starts with the given prefix. */
int startsWith(struct TrieNode* root, char* prefix) {
  return TrieStartWith(root -> Middle, prefix, 0);
}

void FreeTrieTree(TNode root)
{
	if (root == NULL)
		return;

	if (root -> Left)
		FreeTrieTree(root -> Left);
	if (root -> Middle)
		FreeTrieTree(root -> Middle);
	if (root -> Right)
		FreeTrieTree(root -> Right);

	free(root);
}

/** Deallocates memory previously allocated for the TrieNode. */
void trieFree(struct TrieNode* root) {
	FreeTrieTree(root -> Middle);
	free(root);
}

int main(int argc, char const *argv[])
{
	struct TrieNode* node = trieCreate();
	// insert(node, "somestring");
	insert(node, "aaaa");
	insert(node, "aaab");
	insert(node, "aaac");
	insert(node, "aaad");
	insert(node, "aaae");
	insert(node, "aaaf"),
	insert(node, "aaag"),
	insert(node, "aaah"),
	insert(node, "aaai"),
	insert(node, "aaaj"),
	insert(node, "aaak"),
	insert(node, "aaal"),
	insert(node, "aaam"),
	insert(node, "aaan"),
	insert(node, "aaao"),
	insert(node, "aaap"),
	insert(node, "aaaq"),
	insert(node, "aaar"),
	insert(node, "aaas"),
	insert(node, "aaat"),
	insert(node, "aaau"),
	insert(node, "aaav"),
	insert(node, "aaaw"),
	insert(node, "aaax"),
	insert(node, "aaay"),
	insert(node, "aaaz"),
	insert(node, "aaa");
	insert(node, "aab");
	insert(node, "aac");
	insert(node, "aad"),
	insert(node, "aae"),
	insert(node, "aaf"),
	insert(node, "aag"),
	insert(node, "aah"),
	insert(node, "aai"),
	insert(node, "aaj"),
	insert(node, "aak"),
	insert(node, "aal"),
	insert(node, "aam"),
	insert(node, "aan"),
	insert(node, "aao"),
	insert(node, "aap"),
	insert(node, "aaq"),
	insert(node, "aar"),
	insert(node, "aas"),
	insert(node, "aat");
	insert(node, "aau");
	insert(node, "aav");
	insert(node, "aaw");
	insert(node, "aax");
	insert(node, "aay");
	insert(node, "aaz");
	int i1 = search(node, "aaaa"),
	i2 = search(node, "aaaaa"),
	i3 = search(node, "aaa"),
	i4 = search(node, "a"),
	i5 = startsWith(node, "aaaa"),
	i6 = startsWith(node, "aaaaa"),
	i7 = startsWith(node, "aaa"),
	i8 = startsWith(node, "a");
	printf("%d %d %d %d %d %d %d %d\n", i1, i2, i3, i4, i5, i6, i7, i8);
	trieFree(node);

	struct TrieNode* T = trieCreate();
	T = trieCreate();
	insert(T, "ab");
	printf("%d\n", search(T, "ab"));
	printf("%d\n", startsWith(T, "ad"));
	trieFree(T);
	return 0;
}// Given two binary trees, write a function to check if they are equal or not.

// Two binary trees are considered equal if they are structurally identical and the nodes have the same value.

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

#include <stdio.h>

#include "lib/tree.h"

typedef struct TreeNode* Tree;
typedef struct TreeNode* Position;

bool isSameTree(struct TreeNode* p, struct TreeNode* q) {
	if (p == NULL && q == NULL)
		return true;

	if (p == NULL || q == NULL)
		return false;

	if (p -> val != q -> val)
		return false;

	return isSameTree(p -> left, q -> left) && isSameTree(p -> right, q -> right);
}

int main(int argc, char const *argv[])
{
	Tree T, T2;

	T = CreateTree();
	T2 = CreateTree();

	PreOrderTraverse(T);
	printf("\n");

	InOrderTraverse(T);
	printf("\n");

	PostOrderTraverse(T);
	printf("\n");
		
	printf("%d\n", isSameTree(T, T2));
	return 0;
}// Given an integer, write a function to determine if it is a power of two.

#include <stdio.h>

int isPowerOfTwo(int n) {
	if (n <= 0)
		return 0;

	return (n & (n - 1)) == 0;
}

int main(int argc, char const *argv[])
{
	int N;

	N = 9;
	printf("%d\n", isPowerOfTwo(N));
	return 0;
}// Remove all elements from a linked list of integers that have value val.

// Example
// Given: 1 --> 2 --> 6 --> 3 --> 4 --> 5 --> 6, val = 6
// Return: 1 --> 2 --> 3 --> 4 --> 5

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

#include <stdio.h>
#include <stdlib.h>

#include "lib/list.h"

typedef struct ListNode* Position;
typedef struct ListNode* List;

struct ListNode* removeElements(struct ListNode* head, int val) {
  if (head == NULL)
    return NULL;

  Position P, P1;

  P = head;
  while (P != NULL && P -> val == val)
    P = P -> next;

  head = P;
  while (P != NULL)
  {
    for (P1 = P -> next; P1 != NULL && P1 -> val == val; P1 = P1 -> next);
    P -> next = P1;
    P = P -> next;
  }

  return head;
}

int main(int argc, char const *argv[])
{
  List L1, L2, L;

  L1 = CreateEvenList(1);
  L2 = CreateIdenticalList(10);
  L = NewListNode(10);
  L -> next = L2;
  PrintList(L1);
  PrintList(L2);
  PrintList(L);

  L = removeElements(L, 0);
  PrintList(L);
  return 0;
}// Given an array of strings, group anagrams together.

// For example, given: ["eat", "tea", "tan", "ate", "nat", "bat"], 
// Return:

// [
//   ["ate", "eat","tea"],
//   ["nat","tan"],
//   ["bat"]
// ]
// Note:
// For the return value, each inner list's elements must follow the lexicographic order.
// All inputs will be in lower-case.

/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *columnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
char*** groupAnagrams(char** strs, int strsSize, int** columnSizes, int* returnSize) {
    
}/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
/**
 * Return an array of size *returnSize.
 * Note: The returned array must be malloced, assume caller calls free().
 */

#include <stdio.h>
#include <stdlib.h>
#include "lib/tree.h"

typedef struct TreeNode* Tree;
typedef struct TreeNode* Position;

struct RSTreeNode 
{
  Position P;
  int Level;
};

typedef struct RSTreeNode* RSTree;
typedef struct RSTreeNode* RSPosition;

#define ElementType RSPosition
#define SIZE 2

struct QueueRecord
{
  int Front;
  int Rear;
  int Capacity;
  ElementType* Next;
};

typedef struct QueueRecord* Queue;

struct ArrayRecord
{
  int Size;
  int Capacity;
  int* Buffer;
};

typedef struct ArrayRecord* Array;

Queue Initialize()
{
  Queue Q;

  Q = malloc(sizeof(struct QueueRecord));
  Q -> Rear = Q -> Front = 0;
  Q -> Capacity = SIZE;
  Q -> Next = malloc(sizeof(ElementType) * SIZE);

  return Q;
}

int Succ(Queue Q, int Index)
{
  if (++Index >= Q -> Capacity)
    return Index % Q -> Capacity;

  return Index;
}

int isFull(Queue Q)
{
  return Succ(Q, Q -> Front) == Q -> Rear;
}

int isEmpty(Queue Q)
{
  return Q -> Front == Q -> Rear;
}

ElementType Dequeue(Queue Q)
{
  int i;

  if (isEmpty(Q))
  {
    fprintf(stderr, "Empty Queue\n");
    exit(1);
  }

  i = Q -> Rear;
  Q -> Rear = Succ(Q, Q -> Rear);
  return Q -> Next[i];
}


Queue Rearrange(Queue Q)
{
  ElementType *Buffer;
  int i;

  Buffer = malloc(Q -> Capacity * 2 * sizeof(ElementType));

  i = 0;
  while (!isEmpty(Q))
    Buffer[i++] = Dequeue(Q);

  free(Q -> Next);
  Q -> Next = Buffer;
  Q -> Capacity *= 2;
  Q -> Front = i;
  Q -> Rear = 0;
  return Q;
}

void Enqueue(Queue Q, ElementType X)
{
  if (isFull(Q))
    Q = Rearrange(Q);

  Q -> Next[Q -> Front] = X;
  Q -> Front = Succ(Q, Q -> Front);
}

ElementType Rear(Queue Q)
{
  if (isEmpty(Q))
  {
    fprintf(stderr, "Empty Queue\n");
    exit(1);
  }

  return Q -> Next[Q -> Rear];
}

void Destroy(Queue Q)
{
  free(Q -> Next);
  free(Q);
}

RSPosition NewRSNode(Position P, int L)
{
  RSPosition RSP;

  RSP = malloc(sizeof(struct RSTreeNode));
  RSP -> P = P;
  RSP -> Level = L;

  return RSP;
}

void FreeRSNode(RSPosition RSP)
{
  free(RSP -> P);
  free(RSP);
}

Array InitializeArray()
{
  Array A;

  A = malloc(sizeof(struct ArrayRecord));
  A -> Size = 0;
  A -> Capacity = SIZE;
  A -> Buffer = malloc(sizeof(int) * SIZE);

  return A;
}

void PushToArray(Array A, int Value)
{
  if (A -> Size == A -> Capacity)
  {
    A -> Buffer = realloc(A -> Buffer, A -> Capacity * 2 * sizeof(int));
    A -> Capacity *= 2;
  }

  A -> Buffer[A -> Size++] = Value;
}

int* rightSideView(struct TreeNode* root, int* returnSize) {
    Queue Q;
    RSPosition RSP, TopNode;
    Array A;

    if (root == NULL)
    {
      *returnSize = 0;
      return NULL;
    }

    Q = Initialize();
    Enqueue(Q, NewRSNode(root, 0));
    A = InitializeArray();
    while (!isEmpty(Q))
    {
      RSP = Dequeue(Q);

      // PushToArray(A, RSP -> P -> val);

      if (isEmpty(Q))
      {
        PushToArray(A, RSP -> P -> val);
      }
      else
      {
        TopNode = Rear(Q);
        if (RSP -> Level < TopNode -> Level)
          PushToArray(A, RSP -> P -> val);
      }

      if (RSP -> P -> left)
        Enqueue(Q, NewRSNode(RSP -> P -> left, RSP -> Level + 1));

      if (RSP -> P -> right)
        Enqueue(Q, NewRSNode(RSP -> P -> right, RSP -> Level + 1));

      FreeRSNode(RSP);
    }

    Destroy(Q);
    
    *returnSize = A -> Size;
    return A -> Buffer;
}

int main(int argc, char const *argv[])
{
  Tree T;
  int i, returnSize;
  int* Buffer;
  Queue Q;

  T = CreateTree();
  PreOrderTraverse(T);
  printf("\n");

  InOrderTraverse(T);
  printf("\n");
  
  PostOrderTraverse(T);
  printf("\n");
  // MakeEmpty(T);


  // Q = Initialize();
  // for (i = 0; i < 30; ++i)
  //   Enqueue(Q, i);

  // while (!isEmpty(Q))
  //   printf("%d ", Dequeue(Q));
  // printf("\n");
  // T = NULL;
  Buffer = rightSideView(T, &returnSize);
  
  printf("%d\n", returnSize);
  for (i = 0; i < returnSize; ++i)
    printf("%d ", Buffer[i]);
  free(Buffer);
  printf("\n");

  // MakeEmpty(T);
  return 0;
}// Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).

// For example:
// Given binary tree {3,9,20,#,#,15,7},
//     3
//    / \
//   9  20
//     /  \
//    15   7
// return its bottom-up level order traversal as:
// [
//   [15,7],
//   [9,20],
//   [3]
// ]

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *columnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "lib/tree.h"
 
#define SIZE 2

typedef struct LevelReturnRecord* RetPtr;
typedef struct TreeNode* Tree;
typedef struct TreeNode* Position;
typedef struct LevelOrderNode* LNode;
typedef struct QueueRecord* Queue;

#define ElementType LNode

struct LevelOrderNode 
{
	Position P;
	int Level;
};

struct QueueRecord {
	int rear;
	int front;
	ElementType *Array;
	int capacity;
};

struct LevelReturnRecord
{
	int** values;
	int* columnSizes;
	int* columnCapacity;
	int returnSize;
	int currX;
	int currY;
};

Queue Initialize(int size);
int isEmpty(Queue Q);
int Succ(Queue Q, int index);
int isFull(Queue Q);
ElementType Dequeue(Queue Q);
void Rearrange(Queue Q);
void Enqueue(Queue Q, ElementType value);
void Destroy(Queue Q);
LNode NewLNode(Position P, int isLast);
RetPtr InitializeRetRecord();
void PushToRetRecord(RetPtr Ptr, int value, int isLast);

Queue Initialize(int size)
{
	Queue Q;

	Q = malloc(sizeof(struct QueueRecord));
	Q -> rear = 0;
	Q -> front = 0;
	Q -> Array = malloc(sizeof(ElementType) * size);
	Q -> capacity = size;

	return Q;
}

int isEmpty(Queue Q)
{
	return Q -> front == Q -> rear;
}

int Succ(Queue Q, int index)
{
	if (++index >= Q -> capacity)
		return index % Q -> capacity;

	return index;
}

int isFull(Queue Q)
{
	return Succ(Q, Q -> front) == Q -> rear;
}

ElementType Dequeue(Queue Q)
{
	if (isEmpty(Q))
	{
		fprintf(stderr, "Empty Queue\n");
		exit(1);		
	}

	ElementType Value;
	Value = Q -> Array[Q -> rear];
	Q -> rear = Succ(Q, Q -> rear);

	return Value;
}

void Rearrange(Queue Q)
{
	ElementType *Buffer;
	ElementType Value;
	int i;

	Buffer = malloc(sizeof(ElementType) * Q -> capacity * 2);

	i = 0;
	while(!isEmpty(Q))
		Buffer[i++] = Dequeue(Q);

	free(Q -> Array);
	Q -> Array = Buffer;
	Q -> capacity = Q -> capacity * 2;
	Q -> rear = 0;
	Q -> front = i;
}

void Enqueue(Queue Q, ElementType value)
{
	if (isFull(Q))
		Rearrange(Q);

	Q -> Array[Q -> front] = value;
	Q -> front = Succ(Q, Q -> front);
}

ElementType Rear(Queue Q)
{
	if (isEmpty(Q))
	{
		fprintf(stderr, "Empty Queue\n");
		exit(1);		
	}

	return Q -> Array[Q -> rear];
}

void Destroy(Queue Q)
{
	free(Q -> Array);
	free(Q);
}

LNode NewLNode(Position P, int Level)
{
	LNode Node;

	Node = malloc(sizeof(struct LevelOrderNode));
	Node -> P = P;
	Node -> Level = Level;

	return Node;
}


RetPtr InitializeRetRecord()
{
	RetPtr Ptr;
	int i;

	Ptr = malloc(sizeof(struct LevelReturnRecord));
	Ptr -> returnSize = SIZE;

	Ptr -> values = malloc(sizeof(int*) * SIZE);
	for (i = 0; i < Ptr -> returnSize; ++i)
		Ptr -> values[i] = malloc(sizeof(int) * SIZE);

	Ptr -> columnCapacity = malloc(sizeof(int) * SIZE);
	for (i = 0; i <  SIZE; ++i)
		Ptr -> columnCapacity[i] = SIZE;

	Ptr -> columnSizes = malloc(sizeof(int) * SIZE);
	for (i = 0; i <  SIZE; ++i)
		Ptr -> columnSizes[i] = 0;

	Ptr -> currX = 0;
	Ptr -> currY = 0;
	return Ptr;
}

void PushToRetRecord(RetPtr Ptr, int value, int isLast)
{
	int i;

	if (Ptr -> currY >= Ptr -> returnSize)
	{
		Ptr -> values = realloc(Ptr -> values, Ptr -> returnSize * 2 * sizeof(int*));
		Ptr -> returnSize *= 2;

		Ptr -> columnCapacity = realloc(Ptr -> columnCapacity, sizeof(int) * Ptr -> returnSize);
		for (i = Ptr -> returnSize / 2; i <  Ptr -> returnSize; ++i)
			Ptr -> columnCapacity[i] = SIZE;

		Ptr -> columnSizes = realloc(Ptr -> columnSizes, sizeof(int) * Ptr -> returnSize);
		for (i = Ptr -> returnSize / 2; i <  Ptr -> returnSize; ++i)
			Ptr -> columnSizes[i] = 0;


		for (i = Ptr -> returnSize / 2; i < Ptr -> returnSize; ++i)
		{
			Ptr -> values[i] = malloc(sizeof(int) * SIZE);
		}
	}

	if (Ptr -> currX >= Ptr -> columnCapacity[Ptr -> currY])
	{
		Ptr -> values[Ptr -> currY] = realloc(Ptr -> values[Ptr -> currY], sizeof(int) * Ptr -> columnCapacity[Ptr -> currY] * 2);
		Ptr -> columnCapacity[Ptr -> currY] *= 2;
	}

	Ptr -> values[Ptr -> currY][Ptr -> currX++] = value;
	Ptr -> columnSizes[Ptr -> currY]++;

	if (isLast)
	{
		Ptr -> currX = 0;
		Ptr -> currY++;
	}
}

int** levelOrder(struct TreeNode* root, int** columnSizes, int* returnSize) {
    if (root == NULL)
    {
    	*columnSizes = 0;
    	returnSize = 0;
    	return NULL;
    }

    Queue Q;
    ElementType Node;
    ElementType RearNode;
    RetPtr Record;
    int isLast;

    Q = Initialize(SIZE);
    Enqueue(Q, NewLNode(root, 0));

    Record = InitializeRetRecord();

    while(!isEmpty(Q))
    {
    	Node = Dequeue(Q);

    	if (isEmpty(Q))
    	{
    		isLast = 1;
    	}
    	else
    	{
    		RearNode = Rear(Q);

    		if (RearNode -> Level == Node -> Level)
    			isLast = 0;
    		else
    			isLast = 1;
    	}
	    // printf("%d ", Node -> P -> val);
    	
    	if (isLast)
    		PushToRetRecord(Record, Node -> P -> val, 1);
    	else
    		PushToRetRecord(Record, Node -> P -> val, 0);    		

    	if (Node -> P -> left != NULL)
    	{
	    	Enqueue(Q, NewLNode(Node -> P -> left, Node -> Level + 1));
    	}

    	if (Node -> P -> right != NULL)
    	{
	    	Enqueue(Q, NewLNode(Node -> P -> right, Node -> Level + 1));
    	}

    	free(Node);
    }

    Destroy(Q);
    *columnSizes = Record -> columnSizes;
    *returnSize = Record -> currX == 0 ?  Record -> currY : Record -> currY + 1;
    return Record -> values;
}

void testCase()
{
	// int Len, i;
	// int Array[] = {1, 2, 3, 4, 5, 6, 7, 8};
	// Queue Q;
	// ElementType Value;

	// Len = 8;
	// Q = Initialize(2);
	// for (i = 0; i < Len; ++i)
	// 	Enqueue(Q, Array[i]);

	// i = 0;
	// while(!isEmpty(Q))
	// 	assert(Dequeue(Q) == Array[i++]);		

}

int main(int argc, char const *argv[])
{
	Tree T;
	int Len, i, j, returnSize;
	int *columnSizes;
	int **values;
	// int array[] = {8, 7, 4, 10, 9, 12};
	int array[] = {-150, -149, -148, -147, -146, -145, -144, -143, -142};
	T = NULL;
	Len = sizeof(array) / sizeof(array[0]);
	// Len = 64;
	// for (i = 0; i < Len; ++i)
	// 	T = Insert(array[i], T);
	for (i = -105; i <= 600; ++i)
		T = Insert(i, T);
		// T = Insert(rand() % 1024, T);

	// PreOrderTraverse(T);
	// printf("\n");

	// PostOrderTraverse(T);
	// printf("\n");

	values = levelOrder(T, &columnSizes, &returnSize);

	// printf("\n");
	printf("returnSize = %d\n", returnSize);

	printf("columnSizes are ");
	for (i = 0; i < returnSize; ++i)
		printf("%d ", columnSizes[i]);
	printf("\n");

	for (i = 0; i < returnSize; ++i)
	{
		for (j = 0; j < columnSizes[i]; ++j)
			printf("%d ", values[i][j]);
		printf("\n");
	}
	return 0;
}
// Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.

// For example,
// Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.

// Window position                Max
// ---------------               -----
// [1  3  -1] -3  5  3  6  7       3
//  1 [3  -1  -3] 5  3  6  7       3
//  1  3 [-1  -3  5] 3  6  7       5
//  1  3  -1 [-3  5  3] 6  7       5
//  1  3  -1  -3 [5  3  6] 7       6
//  1  3  -1  -3  5 [3  6  7]      7
// Therefore, return the max sliding window as [3,3,5,5,6,7].

/**
 * Return an array of size *returnSize.
 * Note: The returned array must be malloced, assume caller calls free().
 */

#include <stdio.h>
#include <stdlib.h>

#include "lib/test_queue.h"

#define ElementType Position
#define MAX 2

typedef struct QueueRecord* Queue;
typedef struct ItemNode* Position;
typedef struct ResultRecord* Result;

struct ItemNode
{
  int Value;
  int Index;
};

struct QueueRecord
{
  int Front;
  int Rear;
  int Capacity;
  ElementType* Next;
};

Queue Initialize(int Capacity)
{
  Queue Q;

  Q = malloc(sizeof(struct QueueRecord));
  Q -> Front = Q -> Rear = 0;
  Q -> Capacity = Capacity;
  Q -> Next = malloc(sizeof(ElementType) * Capacity);
}

int Succ(Queue Q, int Index)
{
  if (++Index >= Q -> Capacity)
    return Index % Q -> Capacity;

  return Index;
}

int Prev(Queue Q, int Index)
{
  if (--Index < 0)
    return Index + Q -> Capacity;

  return Index;
}

int IsFull(Queue Q)
{
  return Succ(Q, Q -> Rear) == Q -> Front;
}

int IsEmpty(Queue Q)
{
  return Q -> Front == Q -> Rear;
}

ElementType Dequeue(Queue Q)
{
  if (IsEmpty(Q))
  {
    fprintf(stderr, "Empty Queue\n");
    exit(1);
  }

  int Index;
  Index = Q -> Front;
  Q -> Front = Succ(Q, Q -> Front);
  return Q -> Next[Index];
}

void Destroy(Queue Q)
{
  free(Q -> Next);
  free(Q);
}

void Enqueue(Queue Q, ElementType Value)
{
  ElementType *Buffer;
  int i;

  if (IsFull(Q))
  {
    Buffer = malloc(sizeof(ElementType) * Q -> Capacity * 2);
    i = 0;
    while (!IsEmpty(Q))
      Buffer[i++] = Dequeue(Q);

    Q -> Front = 0;
    Q -> Rear = i;
    Q -> Capacity *= 2;
    free(Q -> Next);
    Q -> Next = Buffer;
  }

  Q -> Next[Q -> Rear] = Value;
  Q -> Rear = Succ(Q, Q -> Rear);
  return;
}

ElementType Front(Queue Q)
{
  if (IsEmpty(Q))
  {
    fprintf(stderr, "Empty Queue\n");
    exit(1);
  }

  return Q -> Next[Q -> Front];
}

ElementType Rear(Queue Q)
{
  if (IsEmpty(Q))
  {
    fprintf(stderr, "Empty Queue\n");
    exit(1);
  }

  return Q -> Next[Prev(Q, Q -> Rear)];
}

// Window position                Max
// ---------------               -----
// [1  3  -1] -3  5  3  6  7       3
//  1 [3  -1  -3] 5  3  6  7       3
//  1  3 [-1  -3  5] 3  6  7       5
//  1  3  -1 [-3  5  3] 6  7       5
//  1  3  -1  -3 [5  3  6] 7       6
//  1  3  -1  -3  5 [3  6  7]      7
// Therefore, return the max sliding window as [3,3,5,5,6,7].

Position NewItemNode(int Value, int Index)
{
  Position P;

  P = malloc(sizeof(struct ItemNode));
  P -> Index = Index;
  P -> Value = Value;
  return P;
}

void Swap(ElementType* Numbers, int i, int j)
{
  int Temp;
  Position P;

  Temp = Numbers[i] -> Index;
  Numbers[i] -> Index = Numbers[j] -> Index;
  Numbers[j] -> Index = Temp;

  P = Numbers[i];
  Numbers[i] = Numbers[j];
  Numbers[j] = P;
}

ElementType* InitHeap(int* Numbers, int Size, Queue Q)
{
  ElementType* Heap;
  ElementType Node;
  int i;

  Heap = malloc(sizeof(ElementType) * Size + 1);
  for (i = 0; i < Size; ++i)
  {
    Node = NewItemNode(Numbers[i], i + 1);
    Heap[i+1] = Node;
    Enqueue(Q, Node);
  }

  return Heap;
}

void FixDown(ElementType* Numbers,int k, int Size)
{
  int j;

  while (2 * k <= Size)
  {
    j = 2 * k;
    if (j < Size && Numbers[j] -> Value < Numbers[j+1] -> Value)
      j++;

    if (Numbers[j] -> Value > Numbers[k] -> Value)
    {
      Swap(Numbers, j, k);
      k = j;
    }
    else
      break;
  }
}

void FixUp(ElementType* Numbers, int k, int Size)
{
  while (k / 2 >= 1)
  {
    if (Numbers[k] -> Value > Numbers[k/2] -> Value)
    {
      Swap(Numbers, k, k / 2);
      k = k / 2;
    }   
    else
    {
      break;
    }
  }
}

void BuildHeap(ElementType* Numbers, int Size)
{
  int i;

  for (i = Size / 2; i >= 1; --i)
    FixDown(Numbers, i, Size);
}

struct ResultRecord
{
  int Size;
  int Capacity;
  int* Next;
};

Result InitializeResult(int Capacity)
{
  Result R;

  R = malloc(sizeof(struct ResultRecord));
  R -> Size = 0;
  R -> Capacity = Capacity;
  R -> Next = malloc(sizeof(int) * Capacity);

  return R;
}

void AddToResult(Result R, int Value)
{
  if (R -> Size == R -> Capacity)
  {
    R -> Next = realloc(R -> Next, sizeof(int) * R -> Capacity * 2);
    R -> Capacity *= 2;
  }

  R -> Next[R -> Size++] = Value;
}

void AdjustRandItemInHeap(ElementType* Heap, int k, int Size)
{
  if (k > 1 && Heap[k] -> Value > Heap[k/2] -> Value)
    FixUp(Heap, k, Size);
  else 
    FixDown(Heap, k, Size);
}

int* maxSlidingWindow2(int* nums, int numsSize, int k, int* returnSize) {
  if (nums == NULL || numsSize == 0)
    return NULL;
  
  Result R;
  ElementType* Heap;
  ElementType Node;
  Queue Q;
  int i;

  Q = Initialize(MAX);
  R = InitializeResult(MAX);
  Heap = InitHeap(nums, k, Q);
  BuildHeap(Heap, k);

  for (i = k; i < numsSize; ++i)
  {
    AddToResult(R, Heap[1] -> Value);
    Node = Dequeue(Q);
    Node -> Value = nums[i];
    Enqueue(Q, Node);
    AdjustRandItemInHeap(Heap, Node -> Index, k);
  }

  AddToResult(R, Heap[1] -> Value);
  *returnSize = R -> Size;
  return R -> Next;
}

int* maxSlidingWindow (int* nums, int numsSize, int k, int* returnSize) {

}

// void HeapSort(int* Numbers, int Size)
// {
//  int i;

//  BuildHeap(Numbers, Size);
//  for (i = 0; i < Size - 1; ++i)
//  {
//    Swap(Numbers, 1, Size - 1 - i);
//    FixDown(Numbers, 1, Size - 2 - i);
//  }
// }

int main(int argc, char const *argv[])
{
  // TestQueue();
  int Numbers[] = {1, 3, -1, -3, 5, 3, 6, 7};
  int Len, i, k, ReturnSize;
  int *Result;

  Len = sizeof(Numbers) / sizeof(Numbers[0]);

  // HeapSort(Numbers, Len);

  // for (i = 0; i < Len; ++i)
  //  printf("%d ", Numbers[i]);
  // printf("\n");

  // ElementType* Heap;

  // Heap = InitHeap(Numbers, Len);
  // BuildHeap(Heap, Len);

  // for (i = 1; i < Len; ++i)
  //  printf("%d ", Heap[i] -> Value);

  k = Len;
  Result = maxSlidingWindow(Numbers, Len, k, &ReturnSize);
  printf("%d\n", ReturnSize);
  for (i = 0; i < ReturnSize; ++i)
    printf("%d ", Result[i]);
  printf("\n");
  return 0;
}// Write a program to find the node at which the intersection of two singly linked lists begins.


// For example, the following two linked lists:

// A:          a1 → a2
//                    ↘
//                      c1 → c2 → c3
//                    ↗            
// B:     b1 → b2 → b3
// begin to intersect at node c1.


// Notes:

// If the two linked lists have no intersection at all, return null.
// The linked lists must retain their original structure after the function returns.
// You may assume there are no cycles anywhere in the entire linked structure.
// Your code should preferably run in O(n) time and use only O(1) memory.

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
#include <stdio.h>

#include "lib/list.h"

typedef struct ListNode* Position;
typedef struct ListNode* List;

int GetLengthOfList(List L)
{
	int i;

	i = 0;

	while (L != NULL)
	{
		L = L -> next;
		++i;
	}

	return i;
}

struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
	int Len1, Len2, i;

	if (headA == NULL || headB == NULL)
		return NULL;

	Len1 = GetLengthOfList(headA);
	Len2 = GetLengthOfList(headB);
	
	if (Len1 > Len2)
	{
		for (i = 0; i < Len1 - Len2; ++i)
			headA = headA -> next;
	}

	if (Len2 > Len1)
	{
		for (i = 0; i < Len2 - Len1; ++i)
			headB = headB -> next;
	}

	while (headA != NULL)
	{
		if (headA -> val == headB -> val)
			return headA;

		headA = headA -> next;
		headB = headB -> next;
	}

	return NULL;
}

int main(int argc, char const *argv[])
{
	List L1, L2, L3;
	Position P;

  L1 = CreateList(3);
  PrintList(L1);

  L2 = CreateList(5);
  PrintList(L2);
  
  L3 = CreateList(2);
  PrintList(L3);

	for (P = L1; P -> next != NULL; P = P -> next);
	P -> next = L3;

  PrintList(L1);

 	for (P = L2; P -> next != NULL; P = P -> next);
	P -> next = L3; 

  PrintList(L2);
	
	printf("%d\n", getIntersectionNode(L1, L2) -> val);
	return 0;
}// Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.

// For example,
// Given 1->2->3->3->4->4->5, return 1->2->5.
// Given 1->1->1->2->3, return 2->3.

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

#include <stdio.h>

#include "lib/list.h"

typedef struct ListNode* Position;
typedef struct ListNode* List;

Position FindNextDiffValue(Position P)
{
  Position Node;

  Node = P -> next;
  for (; Node != NULL && Node -> val == P -> val; Node = Node -> next);

  return Node;
}

struct ListNode* deleteDuplicates(struct ListNode* head) {
  if (head == NULL || head -> next == NULL)
    return head;

  Position P1, P2, P;
  List Head;

  Head = NULL;
  P = NULL;
  P1 = head;

  while (P1 != NULL)
  {
    P2 = FindNextDiffValue(P1);

    if (P2 == P1 -> next)
    {
      if (Head == NULL)
      {
        Head = P1;
        P = P1;
      }
      else
      {
        P -> next = P1;
        P = P -> next;
      }
    }

    if (P2 == NULL)
    {
      if (P == NULL)
        return NULL;
      
      if (P1 -> next = NULL)
        P -> next = P1;
      else
        P -> next = NULL;
    }

    P1 = P2;
  }

  return Head;
}

int main(int argc, char const *argv[])
{
  List L1, L2, L;

  L1 = CreateDupList(10);
  PrintList(L1);
  L1 = deleteDuplicates(L1);
  PrintList(L1);
  
  L1 = CreateList(10);
  PrintList(L1);
  L1 = deleteDuplicates(L1);
  PrintList(L1);

  L1 = NewListNode(10);
  L1 -> next = NewListNode(10);
  PrintList(L1);
  L1 = deleteDuplicates(L1);
  // PrintList(L1);
  return 0;
}// Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.

// For example:

// Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].

// Note:
// The order of the result is not important. So in the above example, [5, 3] is also correct.
// Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?

/**
 * Return an array of size *returnSize.
 * Note: The returned array must be malloced, assume caller calls free().
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORD_LENGTH 64

int* singleNumber(int* nums, int numsSize, int* returnSize) {
	int i, j, m, n, Sum, Value;
	int *Numbers1, *Numbers2, *Result;

	if (nums == NULL || numsSize == 0)
	{
		returnSize = 0;
		return NULL;
	}

	Sum = 0;
	for (i = 0; i < numsSize; ++i)
		Sum ^= nums[i];

	for (i = 0; i < WORD_LENGTH; ++i)
		if (Sum & 0x01 == 1)
			break;
		else
			Sum = Sum >> 1;

	for (j = 0, Value = 1; j < i; ++j)
		Value = Value << 1;

	Numbers1 = malloc(sizeof(int) * numsSize);
	Numbers2 = malloc(sizeof(int) * numsSize);
	memset(Numbers1, 0, sizeof(int) * numsSize);
	memset(Numbers2, 0, sizeof(int) * numsSize);

	m = n = 0;
	for (i = 0; i < numsSize; ++i)
	{
		if ((nums[i] & Value) != 0)
			Numbers1[m++] = nums[i];
		else
			Numbers2[n++] = nums[i];
	}

	Result = malloc(sizeof(int) * 2);
	memset(Result, 0, sizeof(int) * 2);
	
	for (i = 0; i < m; ++i)
		Result[0] ^= Numbers1[i];

	for (i = 0; i < n; ++i)
		Result[1] ^= Numbers2[i];

	free(Numbers1);
	free(Numbers2);

	*returnSize = 2;
	return Result;
}

int main(int argc, char const *argv[])
{
	// int Numbers[] = {1, 2, 1, -3, 2, 5};
	int Numbers[] = {1403617094,-490450406,-1756388866,-967931676,1878401007,1878401007,-74743538,1403617094,-1756388866,-74743538,-490450406,-1895772685};
	// int Numbers[] = {2, 3, 3, 2, 1, 4};
	int i, ReturnSize, *Nums;
 
	Nums = singleNumber(Numbers, sizeof(Numbers) / sizeof(Numbers[0]), &ReturnSize);

	for (i = 0; i < ReturnSize; ++i)
		printf("%d ", Nums[i]);
	printf("\n");
	return 0;
}/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
/**
 * Return an array of size *returnSize.
 * Note: The returned array must be malloced, assume caller calls free().
 */

#include <stdio.h>
#include <stdlib.h>

#include "lib/tree.h"

typedef struct TreeNode* Tree;
typedef struct TreeNode* Position;

#define ElementType Position
#define SIZE 8

struct Stack
{
	int Size;
	int Capacity;
	ElementType* Next;
};

typedef struct Stack* Stack;

Stack Initialize()
{
	Stack S;

	S = malloc(sizeof(struct Stack));
	S -> Size = 0;
	S -> Capacity = SIZE;
	S -> Next = malloc(sizeof(ElementType) * SIZE);

	return S;
}

int isEmpty(Stack S)
{
	return S -> Size == 0;
}

int isFull(Stack S)
{
	return S -> Size == S -> Capacity;
}

ElementType Pop(Stack S)
{
	if (isEmpty(S))
	{
		fprintf(stderr, "Empty Stack\n");
		exit(1);
	}

	return S -> Next[--S -> Size];
}

void Push(Stack S, ElementType Value)
{
	if (isFull(S))
	{
		S -> Next = realloc(S -> Next, sizeof(ElementType) * S -> Capacity * 2);
		S -> Capacity *= 2;
	}

	S -> Next[S -> Size++] = Value;
}

void Destroy(Stack S)
{
	free(S -> Next);
	free(S);
}

struct RetRecord
{
	int* Buffer;
	int Size;
	int Capacity;
};

typedef struct RetRecord* Record;

Record InitializeRecord()
{
	Record R;

	R = malloc(sizeof(struct RetRecord));
	R -> Buffer = malloc(sizeof(int) * SIZE);
	R -> Capacity = SIZE;
	R -> Size = 0;

	return R;
}

void PushToRecord(Record R, int Value)
{
	if (R -> Size == R -> Capacity)
	{
		R -> Buffer = realloc(R -> Buffer, R -> Capacity * 2 * sizeof(int));
		R -> Capacity *= 2;
	}

	R -> Buffer[R -> Size++] = Value;
}

int* preorderTraversal(struct TreeNode* root, int* returnSize) 
{
  if (root == NULL)
  {
  	*returnSize = 0;
  	return NULL;
  }

  Stack S;
  Position P;
	Record R;

  S = Initialize();
  R = InitializeRecord();
  Push(S, root);
		
  while(!isEmpty(S))
  {
  	P = Pop(S);

  	PushToRecord(R, P -> val);
  	// printf("%d ", P -> val);

  	if (P -> right)
  		Push(S, P -> right);

  	if (P -> left)
  		Push(S, P -> left);
  }

  *returnSize = R -> Size;
  return R -> Buffer;
}

int main(int argc, char const *argv[])
{
	Tree T;
	int Len, i, returnSize;
	int *Buffer;
	int Array[] = {8, 7, 4, 10, 9, 12};;

	T = NULL;
	Len = sizeof(Array) / sizeof(Array[0]);
	Len = 64;
	for (i = 0; i < Len; ++i)
		T = Insert(rand() % 1024, T);

	PreOrderTraverse(T);
	printf("\n");

	Buffer = preorderTraversal(T, &returnSize);
	printf("%d\n", returnSize);

	for (i = 0; i < returnSize; ++i)
		printf("%d ", Buffer[i]);
	printf("\n");
	return 0;
}/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

#include <stdio.h>
#include <stdlib.h>
#include "lib/tree.h"

typedef struct TreeNode* Tree;
typedef struct TreeNode* Position;

#define ElementType Position

struct StackRecord
{
  int Size;
  int Capacity;
  ElementType* Next;
};

typedef struct StackRecord* Stack;
#define SIZE 2

Stack Initialize()
{
  Stack S;

  S = malloc(sizeof(struct StackRecord));
  S -> Size = 0;
  S -> Capacity = SIZE;
  S -> Next = malloc(sizeof(ElementType) * S -> Capacity);

  return S;
}

int IsEmpty(Stack S)
{
  return S -> Size == 0;
}

int IsFull(Stack S)
{
  return S -> Capacity == S -> Size;
}

ElementType Pop(Stack S)
{
  if (IsEmpty(S))
  {
    fprintf(stderr, "Empty Stack\n");
    exit(1);
  }

  return S -> Next[--S -> Size];
}

void Push(Stack S, ElementType X)
{
  if (IsFull(S))
  {
    S -> Next = realloc(S -> Next, sizeof(ElementType) * S -> Capacity * 2);
    S -> Capacity *= 2;
  }

  S -> Next[S -> Size++] = X;
}

void Destroy(Stack S)
{
  free(S -> Next);
  free(S);
}

int kthSmallest(struct TreeNode* root, int k) {
  Stack S;
  Position Node;
  int i;

  if (root == NULL)
    return 0;

  S = Initialize();
  Node = root;
  i = 0;
  while (Node != NULL || !IsEmpty(S))
  {
    if (Node != NULL)
    {
      Push(S, Node);
      Node = Node -> left;      
    }
    else
    {
      Node = Pop(S);

      if (++i == k)
        break;
      // printf("%d ", Node -> val);

      if (Node -> right)
        Node = Node -> right;
      else
        Node = NULL;
    }
  }

  return Node -> val;
}

int main(int argc, char const *argv[])
{
  Tree T;
  int Value;

  T = CreateTree();

  PreOrderTraverse(T);
  printf("\n");

  InOrderTraverse(T);
  printf("\n");

  PostOrderTraverse(T);
  printf("\n");

  Value = kthSmallest(T, 4);
  printf("Value = %d\n", Value);
  return 0;
}// Given a singly linked list, determine if it is a palindrome.
// Follow up:
// Could you do it in O(n) time and O(1) space?

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

#include <stdio.h>

#include "lib/list.h"

typedef struct ListNode* Position;
typedef struct ListNode* List;

void DisconnectList(List L, List *Head1, List *Head2)
{
	Position P1, P2;
	Position PtrPre, PtrCur, PtrNext;

	P1 = P2 = L;
	PtrPre = P2;
	PtrCur = P2 -> next;

	while (P1 != NULL)
	{
		if (P1 -> next == NULL)
			break;

		P1 = P1 -> next -> next;
		P2 = P2 -> next;

		PtrNext = PtrCur -> next;
		PtrCur -> next = PtrPre;
		PtrPre = PtrCur;
		PtrCur = PtrNext;
	}

	L -> next = NULL;

	if (P1 == NULL)
	{
		P1 = PtrPre -> next;
		PtrPre -> next = PtrCur;
		*Head1 = P1;
		*Head2 = PtrPre;
	}
	else
	{
		*Head1 = PtrPre -> next;
		*Head2 = PtrCur;
	}

	return;
}

int isPalindrome(struct ListNode* head) {
	if (head == NULL || head -> next == NULL)
		return 1;

	List Head1, Head2;
	DisconnectList(head, &Head1, &Head2);

	while (Head1 != NULL && Head2 != NULL)
	{
		if (Head1 -> val != Head2 -> val)
			return 0;

		Head1 = Head1 -> next;
		Head2 = Head2 -> next;
	}

	if (Head1 == NULL || Head2 == NULL)
		return 1;

	return 0;
}

int main(int argc, char const *argv[])
{
	List L1, L2;
	List Head1, Head2;
	Position P;

	L1 = CreateList(3);
	L2 = CreateReversedList(5);
	PrintList(L1);
	PrintList(L2);

	for (P = L1; P -> next != NULL; P = P -> next);
	// P -> next = NewListNode(10);
	// P = P -> next;
	P -> next = L2;
	PrintList(L1);

	// DisconnectList(L1, &Head1, &Head2);
	// PrintList(Head1);
	// PrintList(Head2);

	printf("%d\n", isPalindrome(L1));
	return 0;
}// Evaluate the value of an arithmetic expression in Reverse Polish Notation.

// Valid operators are +, -, *, /. Each operand may be an integer or another expression.

// Some examples:
//   ["2", "1", "+", "3", "*"] -> ((2 + 1) * 3) -> 9
//   ["4", "13", "5", "/", "+"] -> (4 + (13 / 5)) -> 6

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define ElementType int
#define MAX 2

struct StackRecord 
{
	int Size;
	int Capacity;
	ElementType *Next;
};

typedef struct StackRecord* Stack;

Stack Initialize()
{
	Stack S;

	S = malloc(sizeof(struct StackRecord));
	S -> Size = 0;
	S -> Capacity = MAX;
	S -> Next = malloc(sizeof(ElementType) * S -> Capacity);

	return S;
}

int IsEmpty(Stack S)
{
	return S -> Size == 0;
}

int IsFull(Stack S)
{
	return S -> Size == S -> Capacity;
}

void Push(Stack S, ElementType Value)
{
	if (IsFull(S))
	{
		S -> Next = realloc(S -> Next, sizeof(ElementType) * S -> Capacity * 2);
		S -> Capacity *= 2;
	}

	S -> Next[S -> Size++] = Value;
}

ElementType Pop(Stack S)
{
	if (IsEmpty(S))
	{
		fprintf(stderr, "Empty Stack\n");
		exit(1);
	}

	return S -> Next[--S -> Size];
}

void Destroy(Stack S)
{
	free(S -> Next);
	free(S);
}

//   ["2", "1", "+", "3", "*"] -> ((2 + 1) * 3) -> 9
//   ["4", "13", "5", "/", "+"] -> (4 + (13 / 5)) -> 6

#define ISOP(X) (((X) == '+') || ((X) == '-') || ((X) == '*') || ((X) == '/'))

int Operate(int Op1, int Op2, char Operator)
{
	switch (Operator)
	{
		case '+':
			return Op1 + Op2;
		case '-':
			return Op1 - Op2;
		case '*':
			return Op1 * Op2;
		case '/':
			return Op1 / Op2;
	}
}

int evalRPN(char** tokens, int tokensSize) {
	int i;
	int Op1, Op2, Result;
	Stack S;

	S = Initialize();

	for (i = 0; i < tokensSize; ++i)
	{
		if ((strlen(tokens[i]) == 1 )&& ISOP(tokens[i][0]))
		{
			Op2 = Pop(S);
			Op1 = Pop(S);
			Push(S, Operate(Op1, Op2, tokens[i][0]));
		}
		else
		{
			Push(S, atoi(tokens[i]));
		}
	}

	Result = Pop(S);
	Destroy(S);
	return Result;
}

int main(int argc, char const *argv[])
{
	char* tokens[] = {"4", "-3", "+"};
	int Len;

	Len = sizeof(tokens) / sizeof(tokens[0]);
	printf("%d\n", evalRPN(tokens, Len));
	return 0;
}// Follow up for problem "Populating Next Right Pointers in Each Node".

// What if the given tree could be any binary tree? Would your previous solution still work?

// Note:

// You may only use constant extra space.
// For example,
// Given the following binary tree,
//          1
//        /  \
//       2    3
//      / \    \
//     4   5    7
// After calling your function, the tree should look like:
//          1 -> NULL
//        /  \
//       2 -> 3 -> NULL
//      / \    \
//     4-> 5 -> 7 -> NULL

/**
 * Definition for binary tree with next pointer.
 * struct TreeLinkNode {
 *  int val;
 *  struct TreeLinkNode *left, *right, *next;
 * };
 *
 */

#include <stdio.h>

#include "lib/tree.h"

// struct TreeNode {
//   int val;
//   struct TreeNode* left, *right, *next;
// };

typedef struct TreeNode* Position;
typedef struct TreeNode* Tree;

void connect(struct TreeNode *root) {
  if (root == NULL)
    return;

  Position P, P1, P2, PtrStart;
  P = root;
  P1 = P2 = PtrStart = NULL;
  P -> next = NULL;

  while (P != NULL)
  {
    if (P -> left != NULL)
    {
      if (PtrStart == NULL)
        PtrStart = P -> left;

      if (P2 != NULL)
      {
        P2 -> next = P -> left;
        P2 = P2 -> next;
      }
      else
      {
        P2 = P -> left;
      }
    }

    if (P -> right != NULL)
    {
      if (PtrStart == NULL)
        PtrStart = P -> right;

      if (P2 != NULL)
      {
        P2 -> next = P -> right;
        P2 = P2 -> next;
      }
      else
      {
        P2 = P -> right;
      }
    }

    if (P -> next == NULL)
    {
      P = PtrStart;
      if (P2 != NULL)
        P2 -> next = NULL;
      PtrStart = NULL;
      P2 = NULL;
    }
    else
    {
      P = P -> next;
    }
  }
}

int main(int argc, char const *argv[])
{
  Tree T, T2;

  T = CreateTree();
  PreOrderTraverse(T);
  printf("\n");

  InOrderTraverse(T);
  printf("\n");

  PostOrderTraverse(T);
  printf("\n");

  connect(T);
  return 0;
}/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

#include <stdio.h>
#include <stdlib.h>
#include "lib/tree.h"

typedef struct TreeNode* Tree;

int GetDepth(Tree T)
{
  int Depth = 0;

  while (T != NULL)
  {
    T = T -> left;
    ++Depth;
  }

  return Depth;
}

int Pow(int x, int y)
{
  if (y == 1)
    return x;

  if (y == 0)
    return 1;

  int Value;

  Value = Pow(x, y / 2);

  if (y % 2 == 1)
    return Value * Value * x;
  else
    return Value * Value;
}

int countNodes(struct TreeNode* root) {
  if (root == NULL)
    return 0;

  if (root -> left == 0 && root -> right == 0)
    return 1;

  int RightDepth, LeftDepth;

  LeftDepth = GetDepth(root -> left);
  RightDepth = GetDepth(root -> right);

  if (LeftDepth == RightDepth)
    return Pow(2, LeftDepth) + countNodes(root -> right);
  else
    return Pow(2, RightDepth) + countNodes(root -> left);
}

int main(int argc, char const *argv[])
{
  Tree T;

  T = CreateTree();

  PreOrderTraverse(T);
  printf("\n");

  InOrderTraverse(T);
  printf("\n");

  PostOrderTraverse(T);
  printf("\n");


  printf("%d\n", countNodes(T));

  return 0;
}// Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.

// Calling next() will return the next smallest number in the BST.

// Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.


/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

#include <stdlib.h>
#include <stdio.h>

#include "lib/tree.h"

#define SIZE 8

typedef struct TreeNode* Tree;

struct BSTIterator {
   int* next;
   int size;
   int capacity;
   int front;
};


void Push(int value, struct BSTIterator* i)
{
	if (i -> size >= i -> capacity)
	{
		i -> next = realloc(i -> next, i -> capacity * 2 * sizeof(int));
		i -> capacity = i -> capacity * 2;
	}	

	i -> next[i -> size++] = value;
	return;
}

int Pop(struct BSTIterator* i)
{
	if (i -> size == i -> front)
		return;

	return i -> next[i -> front++];
}

int isEmpty(struct BSTIterator* i)
{
	return i -> size == i -> front;
}

void InOrderTraversal(struct TreeNode *root, struct BSTIterator* i)
{
	if (root == NULL)
		return;

	InOrderTraversal(root -> left, i);
	Push(root -> val, i);
	InOrderTraversal(root -> right, i);
}

struct BSTIterator *bstIteratorCreate(struct TreeNode *root) {
	struct BSTIterator* i = malloc(sizeof(struct BSTIterator));
	i -> next = malloc(SIZE * sizeof(int));
	i -> size = 0;
	i -> capacity = SIZE;
	i -> front = 0;

	InOrderTraversal(root, i);
	return i;
}

/** @return whether we have a next smallest number */
int bstIteratorHasNext(struct BSTIterator *iter) {
	return !isEmpty(iter);
}

/** @return the next smallest number */
int bstIteratorNext(struct BSTIterator *iter) {
  return Pop(iter);
}

/** Deallocates memory previously allocated for the iterator */
void bstIteratorFree(struct BSTIterator *iter) {
   free(iter -> next);
   free(iter);
}

/**
 * Your BSTIterator will be called like this:
 * struct BSTIterator *i = bstIteratorCreate(root);
 * while (bstIteratorHasNext(i)) printf("%d\n", bstIteratorNext(i));
 * bstIteratorFree(i);
 */

int main(int argc, char const *argv[])
{
	int array[50] = {};
	Tree T;
	int i, Len, balanced;
	Len = 50;

	for (i = 0; i < Len; ++i)
		array[i] = rand() % 100;

	T = NULL;
	for (i = 0; i < Len; ++i)
		T = Insert(array[i], T);

	PreOrderTraverse(T);
	printf("\n");

  struct BSTIterator *iter = bstIteratorCreate(T);
	while (bstIteratorHasNext(iter)) 
		printf("%d\n", bstIteratorNext(iter));
	bstIteratorFree(iter);
	return 0;
}

// struct BSTIterator *i = bstIteratorCreate(root);
// while (bstIteratorHasNext(i)) 
// 	printf("%d\n", bstIteratorNext(i));
// bstIteratorFree(i);// Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.

// Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].

// The largest rectangle is shown in the shaded area, which has area = 10 unit.

// For example,
// Given height = [2,1,5,6,2,3],
// return 10.

#include <stdio.h>
#include <limits.h>

int largestRectangleArea(int* height, int heightSize) {
	if (heightSize == 0)
		return 0;
	
	int i, j, k;
	int Width, Max, LastOne;

	Max = INT_MIN;
	LastOne = -1;
	for (k = 0; k < heightSize; ++k)
	{
		if (LastOne == height[k])
			continue;

		LastOne = height[k];
		i = j = k;
		while (i >= 0 && height[i] >= height[k]) --i;
		while (j < heightSize && height[j] >= height[k]) ++j;

		Width = j - i - 1;
		if (Max < Width * height[k])
			Max = Width * height[k];
	}   

	return Max;
}

int main(int argc, char const *argv[])
{
	int height[] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
	int Len;

	Len = sizeof(height) / sizeof(height[0]);
	printf("%d\n", largestRectangleArea(height, Len));
	return 0;
}/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

#include "lib/tree.h"

typedef struct TreeNode* Tree;
typedef struct TreeNode* Position;

int Max(int a, int b)
{
	return a > b ? a : b;
}

int Max3(int a, int b, int c)
{
	int x;
	x = a > b ? a : b;
	x = x > c ? x : c;
	return x;
}

int maxTreePathSum(struct TreeNode* root, int* MaxPathSum)
{
  if (root == NULL)
  	return 0;

  if (root -> left == NULL && root -> right == NULL)
  {
	  if (root -> val > *MaxPathSum)
	  	*MaxPathSum = root -> val;

  	return root -> val;  	
  }

  int LeftMaxPathSum, RightMaxPathSum, Tmp;

  LeftMaxPathSum = maxTreePathSum(root -> left, MaxPathSum);
  RightMaxPathSum = maxTreePathSum(root -> right, MaxPathSum);

  if (LeftMaxPathSum > 0 && (LeftMaxPathSum + root -> val > *MaxPathSum))
  	*MaxPathSum = LeftMaxPathSum + root -> val;

  if (RightMaxPathSum > 0 && (RightMaxPathSum + root -> val) > *MaxPathSum)
  	*MaxPathSum = RightMaxPathSum + root -> val;

  if (root -> val > *MaxPathSum)
  	*MaxPathSum = root -> val;

  if (LeftMaxPathSum > 0 && RightMaxPathSum > 0 && (RightMaxPathSum + LeftMaxPathSum + root -> val) > *MaxPathSum)
  	*MaxPathSum = RightMaxPathSum + LeftMaxPathSum + root -> val;

  return Max3(LeftMaxPathSum + root -> val, RightMaxPathSum + root -> val, root -> val);
}

int maxPathSum(struct TreeNode* root) {
	int MaxPathSum = INT_MIN;
	maxTreePathSum(root, &MaxPathSum);
	return MaxPathSum;
}

int main(int argc, char const *argv[])
{
	Tree T;
	int MaxPathSum;

	T = CreateTree();

	PreOrderTraverse(T);
	printf("\n");

	InOrderTraverse(T);
	printf("\n");

	PostOrderTraverse(T);
	printf("\n");

	MaxPathSum = maxPathSum(T);
	printf("%d\n", MaxPathSum);

	return 0;
}// Write a program to check whether a given number is an ugly number.

// Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.

// Note that 1 is typically treated as an ugly number.

#include <stdio.h>

#define FIVE 5
#define TWO 2
#define THREE 3

int Divideable(int Number)
{
	if (Number % FIVE == 0)
		return FIVE;
	else if (Number % TWO == 0)
		return TWO;
	else if (Number % THREE == 0)
		return THREE;
	else
		return -1;
}

int isUgly(int num) {
	if (num <= 0)
		return 0;

	int Factor;

	while (num != 1)
	{
		Factor = Divideable(num);
		if (Factor == -1)
			return 0;

		num /= Factor;
	}

	return 1;
}

int main(int argc, char const *argv[])
{
	int Number;

	Number = 1;
	printf("%d\n", isUgly(Number));
	return 0;
}/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
#include <stdio.h>
#include <stdlib.h>

#include "lib/tree.h"

typedef struct TreeNode* Tree;
typedef struct TreeNode* Position;

int Max(int a, int b)
{
	return a > b ? a : b;
}

int Abs(int a)
{
	if (a < 0)
		return a * -1;

	return a;
}

int Height(Tree T)
{
	int LeftHeight, RightHeight;

	if (T == NULL)
		return 0;

	if (T -> left == NULL && T -> right == NULL)
		return 1;

	LeftHeight = Height(T -> left);
	RightHeight = Height(T -> right);

	return Max(LeftHeight, RightHeight) + 1;
}

int isTreeBalanced(Tree T, int* Height)
{
	int LeftHeight, RightHeight;
	int LeftBalanced, RightBalanced, rootBalanced;

	if (T == NULL)
	{
		*Height = 0;
		return 1;
	}

	if (T -> left == NULL && T -> right == NULL)
	{
		*Height = 1;
		return 1;
	}

	LeftBalanced = isTreeBalanced(T -> left, &LeftHeight);
	RightBalanced = isTreeBalanced(T -> right, &RightHeight);

	*Height = Max(LeftHeight, RightHeight) + 1;
	rootBalanced = Abs(LeftHeight - RightHeight) > 1 ? 0 : 1;

	return rootBalanced && LeftBalanced && RightBalanced;
}

int isBalanced(struct TreeNode* root) {
	int Height;
	return isTreeBalanced(root, &Height);
}

int main(int argc, char const *argv[])
{
	int array[] = {7, 3};
	Tree T;
	int i, Len, balanced;

	Len = sizeof(array) / sizeof(array[0]);
	T = NULL;
	for (i = 0; i < Len; ++i)
		T = Insert(array[i], T);

	PreOrderTraverse(T);
	printf("\n");

	InOrderTraverse(T);
	printf("\n");

	PostOrderTraverse(T);
	printf("\n");

	balanced = isBalanced(T);
	printf("%d\n", balanced);
	return 0;
}// Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.

// Note:
// Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)
// The solution set must not contain duplicate triplets.
//     For example, given array S = {-1 0 1 2 -1 -4},

//     A solution set is:
//     (-1, 0, 1)
//     (-1, -1, 2)

/**
 * Return an array of arrays of size *returnSize.
 * Note: The returned array must be malloced, assume caller calls free().
 */

#include <stdio.h>
#include <stdlib.h>

#define ElementType int
#define TableSize 2
typedef struct HashTbl* HashTable;
typedef struct HTListNode* Position;
typedef struct HTListNode* List;
typedef struct ResultRecord* PtrRR;

struct HashTbl
{
  int Size;
  List* TheLists;
};

struct HTListNode
{
  ElementType Element;
  Position Next;
};

Position NewListNode(int Element)
{
  Position P;

  P = malloc(sizeof(struct HTListNode));
  P -> Element = Element;
  P -> Next = NULL;

  return P;
}

int Hash(int Value)
{
  while (Value < 0)
    Value += TableSize;

  return Value % TableSize;
}

HashTable Initialize(int Size)
{
  HashTable HT;
  int i;

  HT = malloc(sizeof(struct HashTbl));
  HT -> Size = Size;
  HT -> TheLists = malloc(sizeof(List) * Size);

  for (i = 0; i < Size; ++i)
    (HT -> TheLists)[i] = NewListNode(100);

  return HT;
} 

Position Find(HashTable HT, int Value)
{
  List L;
  Position P;

  L = (HT -> TheLists)[Hash(Value)];
  P = L -> Next;

  while (P != NULL)
  {
    if (P -> Element == Value)
      return P;
    P = P -> Next;
  }

  return NULL;
}

void Insert(HashTable HT, int Value)
{
  List L;
  Position P;

  L = (HT -> TheLists)[Hash(Value)];
  P = NewListNode(Value);

  P -> Next = L -> Next;
  L -> Next = P;
  return; 
}

void Remove(HashTable HT, int Value)
{
  List L;
  Position P1, P2;

  L = HT -> TheLists[Hash(Value)];
  P1 = L -> Next;
  P2 = L;

  while (P1 != NULL)
  {
    if (P1 -> Element == Value)
    {
      P2 -> Next = P1 -> Next;
      free(P1);
      return;
    }

    P2 = P1;
    P1 = P1 -> Next;
  }

  return; 
}

void ClearAll(HashTable HT)
{
  int i;
  Position P1, P2;

  for (i = 0; i < HT -> Size; ++i)
  {
    P1 = HT -> TheLists[i] -> Next;
    while (P1 != NULL)
    {
      P2 = P1 -> Next;
      free(P1);
      P1 = P2;
    }

    HT -> TheLists[i] -> Next = NULL;
  }
}

void Destroy(HashTable HT)
{
  int i;
  Position P1, P2;

  ClearAll(HT);

  for (i = 0; i < HT -> Size; ++i)
    free(HT -> TheLists[i]);

  free(HT -> TheLists);
  free(HT);
}

void Swap(int *Array, int i, int j)
{
  int Temp;

  Temp = Array[i];
  Array[i] = Array[j];
  Array[j] = Temp;
}

void SortArray(int *Array, int Left, int Right)
{
  int i, j;
  int Pivot;

  if (Left >= Right)
    return;

  Pivot = Array[Left];
  i = Left + 1;
  j = Right;
  while (1)
  {
    while (i < j && Array[i] < Pivot) ++i;
    while (j > Left && Array[j] >= Pivot) --j;

    if (j <= i)
      break;

    Swap(Array, i, j);
    ++i, --j;
  }

  Swap(Array, Left, j);
  SortArray(Array, Left, j - 1);
  SortArray(Array, j + 1, Right);
}

struct ResultRecord
{
  int Capacity;
  int Size;
  int** Next;
};

PtrRR InitializeRR(int Capacity)
{
  PtrRR RR;

  RR = malloc(sizeof(struct ResultRecord));
  RR -> Capacity = Capacity;
  RR -> Size = 0;
  RR -> Next =  malloc(sizeof(int*) * Capacity);

  return RR;
}

void AddValuesToRR(PtrRR RR, int V1, int V2, int V3)
{
  int i;
  for (i = 0; i < RR -> Size; ++i)
  {
    if (RR -> Next[i][0] == V1 && RR -> Next[i][1] == V2)
      return;
  }

  if (RR -> Size >= RR -> Capacity)
  {
    RR -> Next = realloc(RR -> Next, 2 * RR -> Capacity * sizeof(int*));
    RR -> Capacity *= 2;
  }

  (RR -> Next)[RR -> Size] = malloc(sizeof(int) *  3);
  (RR -> Next)[RR -> Size][0] = V1;
  (RR -> Next)[RR -> Size][1] = V2;
  (RR -> Next)[RR -> Size][2] = V3;
  RR -> Size++;
}

int** threeSum(int* nums, int numsSize, int* returnSize) {
  int i1, i2, Value;
  HashTable HT;
  Position P;
  PtrRR RR;

  SortArray(nums, 0, numsSize - 1);
  HT = Initialize(TableSize);
  RR = InitializeRR(2);

  for (i1 = 0; i1 < numsSize - 2; ++i1)
  {
    Value = 0 - nums[i1];

    for (i2 = i1 + 1; i2 < numsSize; ++i2)
    {
      if ((P = Find(HT, Value - nums[i2])) != NULL)
      {
        // AddValuesToRR(RR, nums[i1], nums[i2], nums[i2]);
        AddValuesToRR(RR, nums[i1], P -> Element, nums[i2]);
      }

      Insert(HT, nums[i2]);
    }

    ClearAll(HT);
  }

  // Destroy(HT);
  *returnSize = RR -> Size;

  return RR -> Next;
}

int main(int argc, char const *argv[])
{
  // int Numbers[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  // int Numbers[] = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
  // int Numbers[] = {-1, -1, -1, -1, -1};
  int Numbers[] = {-4,-2,-2,-2,0,1,2,2,2,3,3,4,4,6,6};
  // int Numbers[] = {-1, 0, 1, 2, -1, -4};
  // int Numbers[] = {0, 0, 0, 0, 0};
  int i, Len;
  int ReturnSize;
  int **ReturnValue;

  Len = sizeof(Numbers) / sizeof(Numbers[0]);
  ReturnValue = threeSum(Numbers, Len, &ReturnSize);

  for (i = 0; i < ReturnSize; ++i)
    printf("%d %d %d\n", ReturnValue[i][0], ReturnValue[i][1], ReturnValue[i][2]);

  // SortArray(Numbers, 0, Len - 1);

  // for (i = 0; i < Len; ++i)
  //  printf("%d ", Numbers[i]);

  // printf("\n");


  // HashTable HT;
  // Position P;
  // HT = Initialize(TableSize);
  // for (i = 1; i < Len; ++i)
  //  Insert(HT, Numbers[i]);

  // for (i = 0; i < Len; ++i)
  // {
  //  P = Find(HT, Numbers[i]);

  //  if (P == NULL)
  //    printf("Not Found\n");
  //  else
  //    printf("%d\n", P -> Element);
  // }

  // Remove(HT, -1);
  // Remove(HT, 2);
  // Remove(HT, 3);

  // for (i = 0; i < Len; ++i)
  // {
  //  P = Find(HT, Numbers[i]);

  //  if (P == NULL)
  //    printf("Not Found\n");
  //  else
  //    printf("%d\n", P -> Element);
  // }

  // ClearAll(HT);

  // PtrRR RR;

  // RR = InitializeRR(12);
  // AddValuesToRR(RR, 1, 2, 3);
  // AddValuesToRR(RR, 2, 2, 3);
  // AddValuesToRR(RR, 3, 2, 3);
  // AddValuesToRR(RR, 4, 2, 3);

  // for (i = 0; i < RR -> Size; ++i)
  // {
  //  printf("%d %d %d\n", (RR -> Next)[i][0], RR -> Next[i][1], RR -> Next[i][2]);
  // }
  return 0;
}// Given a binary tree, determine if it is a valid binary search tree (BST).

// Assume a BST is defined as follows:

// The left subtree of a node contains only nodes with keys less than the node's key.
// The right subtree of a node contains only nodes with keys greater than the node's key.
// Both the left and right subtrees must also be binary search trees.

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

#include <stdio.h>
#include <limits.h>
#include <stdlib.h>

#include "lib/tree.h"
#include "lib/test_stack.h"

typedef struct TreeNode* Tree;
typedef struct TreeNode* Position;

#define ElementType int
#define SIZE 2

struct StackRecord
{
	int Size;
	int Capacity;
	ElementType* Next;
};

typedef struct StackRecord* Stack;

Stack Initialize()
{
	Stack S;

	S = (Stack)malloc(sizeof(struct StackRecord));
	S -> Size = 0;
	S -> Capacity = SIZE;
	S -> Next = (ElementType*)malloc(sizeof(ElementType) * S -> Capacity);
	return S;
}

int IsFull(Stack S)
{
	return S -> Capacity == S -> Size;
}

int IsEmpty(Stack S)
{
	return S -> Size == 0;
}

ElementType Pop(Stack S)
{
	if (IsEmpty(S))
	{
		fprintf(stderr, "Empty Stack\n");
		exit(1);
	}

	return S -> Next[--S -> Size];
}

void Push(Stack S, ElementType X)
{
	if (IsFull(S))
	{
		S -> Next = (ElementType*)realloc(S -> Next, S -> Capacity * 2 * sizeof(ElementType));
		S -> Capacity *= 2;
	}

	S -> Next[S -> Size++] = X;
}

void Destroy(Stack S)
{
	free(S -> Next);
	free(S);
}

void SetMaxMin(int* Value, int* MaxValue, int* MinValue)
{
	if (*Value > *MaxValue)
		*MaxValue = *Value;

	if (*Value < *MinValue)
		*MinValue = *Value;
}

bool ValidateBST(Tree T, int* MaxValue, int *MinValue)
{
	int IsLeftValid, IsRightValid;
	int LeftMaxValue, LeftMinValue, RightMaxValue, RightMinValue;

	if (T == NULL)
	{
		*MaxValue = INT_MIN;
		*MinValue = INT_MAX;		
		return true;
	}

	if (T -> left == NULL && T -> right == NULL)
	{
		SetMaxMin(&T -> val, MaxValue, MinValue);
		return true;
	}

	IsLeftValid = ValidateBST(T -> left, &LeftMaxValue, &LeftMinValue);
	IsRightValid = ValidateBST(T -> left, &RightMaxValue, &RightMinValue);

	SetMaxMin(&T -> val, MaxValue, MinValue);
	return IsLeftValid && IsRightValid && T -> val > LeftMaxValue && T -> val < RightMaxValue;
}	

void GetInOrderTraversal(Tree T, Stack S)
{
	if (T == NULL)
		return;

	GetInOrderTraversal(T -> left, S);
	Push(S, T -> val);
	GetInOrderTraversal(T -> right, S);
}

bool IsAscendantOrder(ElementType* Array, int Size)
{
	int i;

	for (i = 0; i < Size - 1; ++i)
		if (Array[i] >= Array[i+1])
			return false;

	return true;
}

bool isValidBST(struct TreeNode* root) {
	Stack S;
	bool IsValidBST;

	S = Initialize();
	GetInOrderTraversal(root, S);

	IsValidBST = IsAscendantOrder(S -> Next, S -> Size);
	Destroy(S);

	return IsValidBST;
}

int main(int argc, char const *argv[])
{
	Tree T;

	T = CreateTree();
	PreOrderTraverse(T);
	printf("\n");

	InOrderTraverse(T);
	printf("\n");

	PostOrderTraverse(T);
	printf("\n");

	T = NULL;
	printf("%d\n", isValidBST(T));

	TestStack();
	return 0;
}// Write an algorithm to determine if a number is "happy".

// A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.

// Example: 19 is a happy number

// 1^2 + 9^2 = 82
// 8^2 + 2^2 = 68
// 6^2 + 8^2 = 100
// 1^2 + 0^2 + 0^2 = 1

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define ElementType int
#define Prime 17

typedef struct ListNode* Position;
typedef struct ListNode* List;
typedef struct HashTbl* HashTable;

struct ListNode
{
  ElementType val;
  Position next;
};

struct HashTbl
{
  List* TheList;
  int TableSize;
};

int Hash(int Value)
{
  return Value % Prime;
}

Position NewNode(int Value)
{
  Position P;

  P = malloc(sizeof(struct ListNode));
  P -> val = Value;
  P -> next = NULL;

  return P;
}

HashTable Initialize(int Capacity)
{
  HashTable HT;
  int i;

  HT = malloc(sizeof(struct HashTbl));
  HT -> TableSize = Capacity;
  HT -> TheList = malloc(sizeof(Position) * Capacity);

  for (i = 0; i < Capacity; ++i)
  {
    HT -> TheList[i] = NewNode(-1);
  }

  return HT;
}

Position FindAndInsert(HashTable HT, int Value)
{
  List L;
  Position P;

  L = HT -> TheList[Hash(Value)];

  for (P = L -> next; P != NULL; P = P -> next)
  {
    if (P -> val == Value)
      return P;
  }

  P = NewNode(Value);
  P -> next = L -> next;
  L -> next = P;

  return NULL;
}

void DestroyList(List L)
{
  Position P1, P2;
  P1 = L;

  while (P1 != NULL)
  {
    P2 = P1;
    P1 = P1 -> next;
    free(P2);
  }
}

void Destroy(HashTable HT)
{
  int i;

  for (i = 0; i < HT -> TableSize; ++i)
  {
    DestroyList(HT -> TheList[i]);
  }

  free(HT);
}
// Example: 19 is a happy number

// 1^2 + 9^2 = 82
// 8^2 + 2^2 = 68
// 6^2 + 8^2 = 100
// 1^2 + 0^2 + 0^2 = 1

int isHappy(int n) {
  int Sum, Result;
  HashTable HT;

  Sum = 0;
  HT = Initialize(Prime);
  Result = 1;

  while (n != 1)
  {
    if (FindAndInsert(HT, n) != NULL)
    {
      Result = 0;
      break;
    }

    Sum = 0;
    while (n > 0)
    {
      Sum += pow(n % 10, 2);
      n = n / 10;
    }

    n = Sum;
  }

  Destroy(HT);
  return Result;
}

int main(int argc, char const *argv[])
{
  int N;

  N = 32;

  printf("%d\n", isHappy(N));
  return 0;
}// Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.

// For example,
// Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.

// Window position                Max
// ---------------               -----
// [1  3  -1] -3  5  3  6  7       3
//  1 [3  -1  -3] 5  3  6  7       3
//  1  3 [-1  -3  5] 3  6  7       5
//  1  3  -1 [-3  5  3] 6  7       5
//  1  3  -1  -3 [5  3  6] 7       6
//  1  3  -1  -3  5 [3  6  7]      7
// Therefore, return the max sliding window as [3,3,5,5,6,7].

/**
 * Return an array of size *returnSize.
 * Note: The returned array must be malloced, assume caller calls free().
 */

#include <stdio.h>
#include <stdlib.h>

#include "lib/test_queue.h"

#define ElementType int
#define MAX 2

typedef struct QueueRecord* Queue;
typedef struct ResultRecord* Result;

struct QueueRecord
{
  int Front;
  int Rear;
  int Capacity;
  ElementType* Next;
};

Queue Initialize(int Capacity)
{
  Queue Q;

  Q = malloc(sizeof(struct QueueRecord));
  Q -> Front = Q -> Rear = 0;
  Q -> Capacity = Capacity;
  Q -> Next = malloc(sizeof(ElementType) * Capacity);
}

int Succ(Queue Q, int Index)
{
  if (++Index >= Q -> Capacity)
    return Index % Q -> Capacity;

  return Index;
}

int Prev(Queue Q, int Index)
{
  if (--Index < 0)
    return Index + Q -> Capacity;

  return Index;
}

int IsFull(Queue Q)
{
  return Succ(Q, Q -> Rear) == Q -> Front;
}

int IsEmpty(Queue Q)
{
  return Q -> Front == Q -> Rear;
}

ElementType Dequeue(Queue Q)
{
  if (IsEmpty(Q))
  {
    fprintf(stderr, "Empty Queue\n");
    exit(1);
  }

  int Index;
  Index = Q -> Front;
  Q -> Front = Succ(Q, Q -> Front);
  return Q -> Next[Index];
}

ElementType PopBack(Queue Q)
{
  if (IsEmpty(Q))
  {
    fprintf(stderr, "Empty Queue\n");
    exit(1);
  }

  int Index;

  Index = Q -> Rear - 1;
  Q -> Rear = Prev(Q, Q -> Rear);
  return Q -> Next[Index];
}

void Destroy(Queue Q)
{
  free(Q -> Next);
  free(Q);
}

void Enqueue(Queue Q, ElementType Value)
{
  ElementType *Buffer;
  int i;

  if (IsFull(Q))
  {
    Buffer = malloc(sizeof(ElementType) * Q -> Capacity * 2);
    i = 0;
    while (!IsEmpty(Q))
      Buffer[i++] = Dequeue(Q);

    Q -> Front = 0;
    Q -> Rear = i;
    Q -> Capacity *= 2;
    free(Q -> Next);
    Q -> Next = Buffer;
  }

  Q -> Next[Q -> Rear] = Value;
  Q -> Rear = Succ(Q, Q -> Rear);
  return;
}

ElementType Front(Queue Q)
{
  if (IsEmpty(Q))
  {
    fprintf(stderr, "Empty Queue\n");
    exit(1);
  }

  return Q -> Next[Q -> Front];
}

ElementType Rear(Queue Q)
{
  if (IsEmpty(Q))
  {
    fprintf(stderr, "Empty Queue\n");
    exit(1);
  }

  return Q -> Next[Prev(Q, Q -> Rear)];
}

struct ResultRecord
{
  int Size;
  int Capacity;
  int* Next;
};

Result InitializeResult(int Capacity)
{
  Result R;

  R = malloc(sizeof(struct ResultRecord));
  R -> Size = 0;
  R -> Capacity = Capacity;
  R -> Next = malloc(sizeof(int) * Capacity);

  return R;
}

void AddToResult(Result R, int Value)
{
  if (R -> Size == R -> Capacity)
  {
    R -> Next = realloc(R -> Next, sizeof(int) * R -> Capacity * 2);
    R -> Capacity *= 2;
  }

  R -> Next[R -> Size++] = Value;
}

// int Numbers[] = {9,10,9,-7,-4,-8,2,-6};
int* maxSlidingWindow (int* nums, int numsSize, int k, int* returnSize) {
  Queue Q;
  Result R;
  int i;

  if (nums == NULL || numsSize == 0)
    return NULL;

  Q = Initialize(MAX);
  R = InitializeResult(MAX);

  for (i = 0; i < k; ++i)
  {
    while (!IsEmpty(Q) && nums[Rear(Q)] < nums[i])
      PopBack(Q);

    Enqueue(Q, i);
  }

  for (i = k; i < numsSize; ++i)
  {
    AddToResult(R, nums[Front(Q)]);
    if (Front(Q) <= i - k)
      Dequeue(Q);

    while (!IsEmpty(Q) && nums[Rear(Q)] <= nums[i])
      PopBack(Q);

    Enqueue(Q, i);
  }

  AddToResult(R, nums[Front(Q)]);
  Destroy(Q);

  *returnSize = R -> Size;
  return R -> Next;
}

int main(int argc, char const *argv[])
{
  // TestQueue();
  // int Numbers[] = {2, 4, 7};
  // int Numbers[] = {1, 3, -1, -3, 5, 3, 6, 7};
  int Numbers[] = {9,10,9,-7,-4,-8,2,-6};
  int Len, i, k, ReturnSize;
  int *Result;

  Len = sizeof(Numbers) / sizeof(Numbers[0]);
  k = 3;
  Result = maxSlidingWindow(Numbers, Len, k, &ReturnSize);
  printf("%d\n", ReturnSize);
  for (i = 0; i < ReturnSize; ++i)
    printf("%d ", Result[i]);
  printf("\n");
  return 0;
}// Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k.

#include <stdio.h>
#include <stdlib.h>

#define Prime 17

typedef struct IndexListNode* Position;
typedef struct IndexListNode* List;
typedef struct HashTbl* HashTable;

struct IndexListNode
{
  int Index;
  int Value;
  Position Next;
};

struct HashTbl
{
  int TableSize;
  List* TheList;
};

Position NewNode(int Value, int Index)
{
  Position P;

  P = malloc(sizeof(struct IndexListNode));
  P -> Value = Value;
  P -> Index = Index;
  P -> Next = NULL;

  return P;
}

HashTable Initialze(int Capacity)
{
  HashTable HT;
  int i;

  HT = malloc(sizeof(struct HashTbl));
  HT -> TableSize = Capacity;
  HT -> TheList = malloc(sizeof(Position) * Capacity);

  for (i = 0; i < Capacity; ++i)
  {
    HT -> TheList[i] = NewNode(-1, -1);
  }

  return HT;
}

int Hash(int Value)
{
  while (Value < 0)
    Value += Prime;

  return Value % Prime;
}

int FindAndInsert(HashTable HT, int Value, int Index, int k)
{
  List L;
  Position P;

  L = HT -> TheList[Hash(Value)];
  P = L -> Next;

  for (; P != NULL; P = P -> Next)
  {
    if (P -> Value == Value)
    {
      if (Index - P -> Index <= k)
        return 1;
      else
        break;
    }
  }

  P = NewNode(Value, Index);
  P -> Next = L -> Next;
  L -> Next = P;
  return 0;
}

void DestroyList(List L)
{
  if (L == NULL)
    return;

  Position P1, P2;

  P1 = L;
  while (P1 != NULL)
  {
    P2 = P1 -> Next;
    free(P1);
    P1 = P2;
  }
}

void Destroy(HashTable HT)
{
  int i;

  for (i = 0; i < HT -> TableSize; ++i)
  {
    DestroyList(HT -> TheList[i]);
  }

  free(HT);
}

int containsNearbyDuplicate(int* nums, int numsSize, int k) {
  HashTable HT;
  Position P;
  int i, j, Value;

  if (nums == NULL || numsSize <= 1)
    return 0;
  
  HT = Initialze(Prime);
  Value = 0;
  for (i = 0; i < numsSize; ++i)
  {
    if (FindAndInsert(HT, nums[i], i, k) == 1)
    {
      Value = 1;
      break;
    }
  }

  Destroy(HT);
  return Value;
}

int main(int argc, char const *argv[])
{
  int Numbers[] = {1, 2, 3, 11, 4, 12, 13, 2, 1};
  int Len, i;

  Len = sizeof(Numbers) / sizeof(Numbers[0]);

  printf("%d\n", containsNearbyDuplicate(Numbers, Len, 5));
  return 0;
}// Given an absolute path for a file (Unix-style), simplify it.

// For example,
// path = "/home/", => "/home"
// path = "/a/./b/../../c/", => "/c"
// click to show corner cases.

// Corner Cases:
// Did you consider the case where path = "/../"?
// In this case, you should return "/".
// Another corner case is the path might contain multiple slashes '/' together, such as "/home//foo/".
// In this case, you should ignore redundant slashes and return "/home/foo".

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define ElementType char*
#define MAX 2

struct StackRecord
{
	int Size;
	int Capacity;
	ElementType* Next;
};

typedef struct StackRecord* Stack;

Stack Initialize(int Capacity)
{
	Stack S;

	S = malloc(sizeof(struct StackRecord));
	S -> Size = 0;
	S -> Capacity = Capacity;
	S -> Next = malloc(sizeof(ElementType) * Capacity);

	return S;
}

int IsEmpty(Stack S)
{
	return S -> Size == 0;
}

int IsFull(Stack S)
{
	return S -> Size == S -> Capacity;
}

void Push(Stack S, ElementType Value)
{
	if (IsFull(S))
	{
		S -> Next = realloc(S -> Next, sizeof(ElementType) * S -> Capacity * 2);
		S -> Capacity *= 2;
	}

	S -> Next[S -> Size++] = Value;
}

ElementType Pop(Stack S)
{
	if (IsEmpty(S))
	{
		fprintf(stderr, "Empty Stack\n");
		exit(1);
	}

	return S -> Next[-- S -> Size];
}

void Destroy(Stack S)
{
	free(S -> Next);
	free(S);
}

struct PathRecord
{
	int Size;
	int Capacity;
	char* Buffer;
};

typedef struct PathRecord* Path;

Path InitPathRecord(int Capacity)
{
	Path P;

	P = malloc(sizeof(struct PathRecord));
	P -> Size = 0;
	P -> Capacity = 2;
	P -> Buffer = malloc(sizeof(char*) * Capacity);
	memset(P -> Buffer, 0, P -> Capacity);
	return P;
}

void AddDirToPath(Path P, char* Dir)
{
	int DirLen;

	DirLen = strlen(Dir);
	// The extra chars, one for '/', one for '\0'
	if (DirLen + P -> Size + 1 > P -> Capacity)
	{
		P -> Buffer = realloc(P -> Buffer, sizeof(char*) * P -> Capacity * 2);
		P -> Capacity *= 2;
	}

	strcat(P -> Buffer + P -> Size, Dir);
	P -> Buffer[P -> Size + DirLen + 1] = '\0';
	P -> Size += DirLen;
}

char* JoinStackToPath(Stack S)
{
	Path P;
	char* Dir;

	P = InitPathRecord(MAX);

	while (!IsEmpty(S))
	{
		AddDirToPath(P, "/");
		Dir = Pop(S);
		AddDirToPath(P, Dir);
	}

	if (P -> Size == 0)
		AddDirToPath(P, "/");
	
	return P -> Buffer;
}

void Reverse(char** Buffer, int Len)
{
	int i, j;
	char* Tmp;

	i = 0;
	j = Len - 1;

	while (i < j)
	{
		Tmp = Buffer[i];
		Buffer[i] = Buffer[j];
		Buffer[j] = Tmp;
		++i, --j;
	}
}

char* simplifyPath(char* path) {
	char* Ptr, *SimplifiedPath;
	Stack S;

	S = Initialize(MAX);
	while ((Ptr = strtok(path, "/")) != NULL)
	{
		if (strcmp(Ptr, "..") == 0)
		{
			if (!IsEmpty(S))
			{
				Pop(S);
			}
		}
		else if (strcmp(Ptr, ".") == 0)
		{
		}
		else
		{
			Push(S, Ptr);
		}

		path = NULL;
	}

	Reverse(S -> Next, S -> Size);
	SimplifiedPath = JoinStackToPath(S);
	return SimplifiedPath;
}

int main(int argc, char const *argv[])
{
	char *SimplifiedPath;
	// char path[] = "/home/./b/../../c/";
	// SimplifiedPath = simplifyPath(path);
	// printf("%s\n", SimplifiedPath);

	// char path2[] = "/../";
	// SimplifiedPath = simplifyPath(path2);
	// printf("%s\n", SimplifiedPath);

	// char path3[] = "/home//foo/";
	// SimplifiedPath = simplifyPath(path3);
	// printf("%s\n", SimplifiedPath);

	char path4[] = "/ZUEKUr/////mQgCnRJfQNIZg/.///./YpBxTyhpmtYyJfeiQWxb/../DLsEfOyEcdqu/../KBBImXbXDEclofboL/tUwMwZzcvkFfizDilg///.///gM/cBmkdtUVdAQ/gCgcGeobJBMCDGIXw/sMXnmxXrzBpkmssuPKT/atCyXalaSgmDFpvahvQW///SrctZaeLTddJKXlPHFNq/.././////./../yRNwSo/JEUmkcvANwvsrw/FhSrydvzDBCrtLTaZ/XrXtPuxAMuXFrbKuOh/./.././../FUEiMcTe/////../srNGnzVZxWOUpe/././YNtjpYYLQWoaBlJIEWM/..///./..///klHbRNEJLWvSaz/////GzNkpNWWPlLzkWrbGf/../zgZHxxnK/Ha///RUJfZEo/w/wSPgfJcSCZnKlU/../WacBhJNVvbJEARNLTN/../D/HYsTPrFyLEFX/YlPvoXcHUP/../VCeexmaHTqdbY///////././////iHWYv/////ZhMwruOuSAwsd/../../Gkr/VICeU/trbQemaHKwYpQ///ZJoPXJfbIeMQoQw/../yZRXdPdVOTgIHBW/..///uvzdgjWtD/../////JTbuiwNrWCyEERc///aWoePM///////lhPTKameBojoskHf/.///./../GNmRJROCxIhHkl/wWiRZiqA/QMjifqukwQ/UIKpIhcRmPlM/.///VhVxNrzgj/./../cdNIgbBP/CkGu/lqjZJHdyfbpVdQsygw/gTkQkHSqfHNFOQ/.././JhugsGGBRd/EJwkObqLYxQ/LSWEObQHwFWztAB/./CuyLucgUfNkE/////////vdu/fwdgPpD////";
	SimplifiedPath = simplifyPath(path4);
	printf("%s\n", SimplifiedPath);
	// char* pathes[] = { "home", "deploy", "cap", "cms", "current", "app" };
	// char* pathes[] = { "h", "b" };
	// int Len;
	// Path P;

	// Len = sizeof(pathes) / sizeof(pathes[0]);
	// P = InitPathRecord(MAX);
	// int i;

	// for (i = 0; i < Len; ++i)
	// {
	// 	AddDirToPath(P, pathes[i]);
	// }

	// printf("%s\n", P -> Buffer);

	return 0;
}// Sort a linked list using insertion sort.

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

#include <stdio.h>

#include "lib/list.h"

typedef struct ListNode* Position;
typedef struct ListNode* List;

void Swap(Position P1, Position P2)
{
  int Temp;

  Temp = P1 -> val;
  P1 -> val = P2 -> val;
  P2 -> val = Temp;
}

struct ListNode* insertionSortList(struct ListNode* head) {
  if (head == NULL)
    return NULL;

  Position P1, P2, PtrNode;

  P1 = head -> next;
  P2 = head;
  while (P1 != NULL)
  {
    if (P1 -> val < P2 -> val)
    {
      PtrNode = head;
      while (PtrNode -> val < P1 -> val && PtrNode != P1)
        PtrNode = PtrNode -> next;

      if (PtrNode != P1)
      {
        P2 -> next = P1 -> next;
        Swap(P1, PtrNode);
        P1 -> next = PtrNode -> next;
        PtrNode -> next = P1;
      }
    }

    P2 = P1;
    P1 = P1 -> next;
  }

  return head;
}

int main(int argc, char const *argv[])
{
  List L;
  
  L = CreateRandList(16);
  PrintList(L);

  L = insertionSortList(L);
  PrintList(L);
  DestroyList(L);

  L = CreateReversedList(16);
  PrintList(L);

  L = insertionSortList(L);
  PrintList(L);
  DestroyList(L);

  L = CreateList(16);
  PrintList(L);

  L = insertionSortList(L);
  PrintList(L);
  DestroyList(L);

  return 0;
}// Write a function that takes an unsigned integer and returns the number of ’1' bits it has (also known as the Hamming weight).

// For example, the 32-bit integer ’11' has binary representation 00000000000000000000000000001011, so the function should return 3.

#include <stdio.h>

int hammingWeight(int n) {
	int i;

	if (n == 0)
		return 0;

	i = 1;
	while ((n = (n & (n - 1))) != 0)
		++i;

	return i;
}

int main(int argc, char const *argv[])
{
	int N;

	N = -1;

	printf("%d\n", hammingWeight(N));
	printf("%d\n", sizeof(int));
	return 0;
}// Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).

// For example:
// Given binary tree {3,9,20,#,#,15,7},
//     3
//    / \
//   9  20
//     /  \
//    15   7
// return its bottom-up level order traversal as:
// [
//   [15,7],
//   [9,20],
//   [3]
// ]

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *columnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "lib/tree.h"

#define SIZE 2

typedef struct LevelReturnRecord* RetPtr;
typedef struct TreeNode* Tree;
typedef struct TreeNode* Position;
typedef struct LevelOrderNode* LNode;
typedef struct QueueRecord* Queue;

#define ElementType LNode

struct LevelOrderNode 
{
	Position P;
	int Level;
};

struct QueueRecord {
	int rear;
	int front;
	ElementType *Array;
	int capacity;
};

struct LevelReturnRecord
{
	int** values;
	int* columnSizes;
	int* columnCapacity;
	int returnSize;
	int currX;
	int currY;
};

Queue Initialize(int size);
int isEmpty(Queue Q);
int Succ(Queue Q, int index);
int isFull(Queue Q);
ElementType Dequeue(Queue Q);
void Rearrange(Queue Q);
void Enqueue(Queue Q, ElementType value);
void Destroy(Queue Q);
LNode NewLNode(Position P, int isLast);
RetPtr InitializeRetRecord();
void PushToRetRecord(RetPtr Ptr, int value, int isLast);

Queue Initialize(int size)
{
	Queue Q;

	Q = malloc(sizeof(struct QueueRecord));
	Q -> rear = 0;
	Q -> front = 0;
	Q -> Array = malloc(sizeof(ElementType) * size);
	Q -> capacity = size;

	return Q;
}

int isEmpty(Queue Q)
{
	return Q -> front == Q -> rear;
}

int Succ(Queue Q, int index)
{
	if (++index >= Q -> capacity)
		return index % Q -> capacity;

	return index;
}

int isFull(Queue Q)
{
	return Succ(Q, Q -> front) == Q -> rear;
}

ElementType Dequeue(Queue Q)
{
	if (isEmpty(Q))
	{
		fprintf(stderr, "Empty Queue\n");
		exit(1);		
	}

	ElementType Value;
	Value = Q -> Array[Q -> rear];
	Q -> rear = Succ(Q, Q -> rear);

	return Value;
}

void Rearrange(Queue Q)
{
	ElementType *Buffer;
	ElementType Value;
	int i;

	Buffer = malloc(sizeof(ElementType) * Q -> capacity * 2);

	i = 0;
	while(!isEmpty(Q))
		Buffer[i++] = Dequeue(Q);

	free(Q -> Array);
	Q -> Array = Buffer;
	Q -> capacity = Q -> capacity * 2;
	Q -> rear = 0;
	Q -> front = i;
}

void Enqueue(Queue Q, ElementType value)
{
	if (isFull(Q))
		Rearrange(Q);

	Q -> Array[Q -> front] = value;
	Q -> front = Succ(Q, Q -> front);
}

ElementType Rear(Queue Q)
{
	if (isEmpty(Q))
	{
		fprintf(stderr, "Empty Queue\n");
		exit(1);		
	}

	return Q -> Array[Q -> rear];
}

void Destroy(Queue Q)
{
	free(Q -> Array);
	free(Q);
}

LNode NewLNode(Position P, int Level)
{
	LNode Node;

	Node = malloc(sizeof(struct LevelOrderNode));
	Node -> P = P;
	Node -> Level = Level;

	return Node;
}


RetPtr InitializeRetRecord()
{
	RetPtr Ptr;
	int i;

	Ptr = malloc(sizeof(struct LevelReturnRecord));
	Ptr -> returnSize = SIZE;

	Ptr -> values = malloc(sizeof(int*) * SIZE);
	for (i = 0; i < Ptr -> returnSize; ++i)
		Ptr -> values[i] = malloc(sizeof(int) * SIZE);

	Ptr -> columnCapacity = malloc(sizeof(int) * SIZE);
	for (i = 0; i <  SIZE; ++i)
		Ptr -> columnCapacity[i] = SIZE;

	Ptr -> columnSizes = malloc(sizeof(int) * SIZE);
	for (i = 0; i <  SIZE; ++i)
		Ptr -> columnSizes[i] = 0;

	Ptr -> currX = 0;
	Ptr -> currY = 0;
	return Ptr;
}

void PushToRetRecord(RetPtr Ptr, int value, int isLast)
{
	int i;

	if (Ptr -> currY >= Ptr -> returnSize)
	{
		Ptr -> values = realloc(Ptr -> values, Ptr -> returnSize * 2 * sizeof(int*));
		Ptr -> returnSize *= 2;

		Ptr -> columnCapacity = realloc(Ptr -> columnCapacity, sizeof(int) * Ptr -> returnSize);
		for (i = Ptr -> returnSize / 2; i <  Ptr -> returnSize; ++i)
			Ptr -> columnCapacity[i] = SIZE;

		Ptr -> columnSizes = realloc(Ptr -> columnSizes, sizeof(int) * Ptr -> returnSize);
		for (i = Ptr -> returnSize / 2; i <  Ptr -> returnSize; ++i)
			Ptr -> columnSizes[i] = 0;


		for (i = Ptr -> returnSize / 2; i < Ptr -> returnSize; ++i)
		{
			Ptr -> values[i] = malloc(sizeof(int) * SIZE);
		}
	}

	if (Ptr -> currX >= Ptr -> columnCapacity[Ptr -> currY])
	{
		Ptr -> values[Ptr -> currY] = realloc(Ptr -> values[Ptr -> currY], sizeof(int) * Ptr -> columnCapacity[Ptr -> currY] * 2);
		Ptr -> columnCapacity[Ptr -> currY] *= 2;
	}

	Ptr -> values[Ptr -> currY][Ptr -> currX++] = value;
	Ptr -> columnSizes[Ptr -> currY]++;

	if (isLast)
	{
		Ptr -> currX = 0;
		Ptr -> currY++;
	}
}

void reverseIntArray(int** array, int size)
{
	int i;
	int temp;

	for (i = 0; i < size / 2; ++i)
	{
		temp = (*array)[i];
		(*array)[i] = (*array)[size - i - 1];
		(*array)[size - i - 1] = temp;
	}
}

void reversePointerArray(int** array, int size)
{
	int i;
	int *temp;

	for (i = 0; i < size / 2; ++i)
	{
		temp = *(array + i);
		*(array + i) = *(array + size - i - 1);
		*(array + size - i - 1) = temp;
	}
}

int** levelOrder(struct TreeNode* root, int** columnSizes, int* returnSize) {
    if (root == NULL)
    {
    	*columnSizes = 0;
    	returnSize = 0;
    	return NULL;
    }

    Queue Q;
    ElementType Node;
    ElementType RearNode;
    RetPtr Record;
    int isLast;

    Q = Initialize(SIZE);
    Enqueue(Q, NewLNode(root, 0));

    Record = InitializeRetRecord();

    while(!isEmpty(Q))
    {
    	Node = Dequeue(Q);

    	if (isEmpty(Q))
    	{
    		isLast = 1;
    	}
    	else
    	{
    		RearNode = Rear(Q);

    		if (RearNode -> Level == Node -> Level)
    			isLast = 0;
    		else
    			isLast = 1;
    	}
	    // printf("%d ", Node -> P -> val);
    	
    	if (isLast)
    		PushToRetRecord(Record, Node -> P -> val, 1);
    	else
    		PushToRetRecord(Record, Node -> P -> val, 0);    		

    	if (Node -> P -> left != NULL)
    	{
	    	Enqueue(Q, NewLNode(Node -> P -> left, Node -> Level + 1));
    	}

    	if (Node -> P -> right != NULL)
    	{
	    	Enqueue(Q, NewLNode(Node -> P -> right, Node -> Level + 1));
    	}

    	free(Node);
    }

    Destroy(Q);
    *columnSizes = Record -> columnSizes;
    *returnSize = Record -> currX == 0 ?  Record -> currY : Record -> currY + 1;

    reverseIntArray(columnSizes, *returnSize);
    reversePointerArray(Record -> values, *returnSize);

    return Record -> values;
}

void testCase()
{
	// int Len, i;
	// int Array[] = {1, 2, 3, 4, 5, 6, 7, 8};
	// Queue Q;
	// ElementType Value;

	// Len = 8;
	// Q = Initialize(2);
	// for (i = 0; i < Len; ++i)
	// 	Enqueue(Q, Array[i]);

	// i = 0;
	// while(!isEmpty(Q))
	// 	assert(Dequeue(Q) == Array[i++]);		

}

int main(int argc, char const *argv[])
{
	Tree T;
	int Len, i, j, returnSize;
	int *columnSizes;
	int **values;
	// int array[] = {8, 7, 4, 10, 9, 12};
	// int array[] = {-150, -149, -148, -147, -146, -145, -144, -143, -142};
	T = NULL;
	// Len = sizeof(array) / sizeof(array[0]);
	// Len = 64;
	// for (i = 0; i < Len; ++i)
	// 	T = Insert(array[i], T);
	for (i = -105; i <= 600; ++i)
		T = Insert(i, T);
		// T = Insert(rand() % 1024, T);

	// PreOrderTraverse(T);
	// printf("\n");

	// PostOrderTraverse(T);
	// printf("\n");

	values = levelOrder(T, &columnSizes, &returnSize);

	// printf("\n");
	printf("returnSize = %d\n", returnSize);

	printf("columnSizes are ");
	for (i = 0; i < returnSize; ++i)
		printf("%d ", columnSizes[i]);
	printf("\n");

	for (i = 0; i < returnSize; ++i)
	{
		for (j = 0; j < columnSizes[i]; ++j)
			printf("%d ", values[i][j]);
		printf("\n");
	}
	return 0;
}
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include "lib/tree.h"

typedef struct TreeNode* Tree;
typedef struct TreeNode* Position;


int Min(int a, int b)
{
  return a > b ? b : a;
}

int minTreeDepth(struct TreeNode* root)
{
  if (root == NULL)
    return INT_MAX;

  if (root -> left == NULL && root -> right == NULL)
    return 1;

  int leftDepth, rightDepth;

  leftDepth = minTreeDepth(root -> left);
  rightDepth = minTreeDepth(root -> right);

  return Min(leftDepth, rightDepth) + 1;
}

int minDepth(struct TreeNode* root) {
  if (root == NULL)
    return 0;

  return minTreeDepth(root);
}

int main(int argc, char const *argv[])
{
  Tree T;
  int Depth;

  T = CreateTree();

  PreOrderTraverse(T);
  printf("\n");

  InOrderTraverse(T);
  printf("\n");

  PostOrderTraverse(T);
  printf("\n");

  Depth = minDepth(T);
  printf("%d\n", Depth);
  return 0;
}/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

#include <stdio.h>
#include <stdlib.h>
#include "lib/tree.h"

typedef struct TreeNode* Tree;
typedef struct TreeNode* Position;

struct TreeNode* buildTree(int* inorder, int inorderSize, int* postorder, int postorderSize) {
  if (inorder == NULL || postorder == NULL || inorderSize == 0 || postorderSize == 0)
    return NULL;

  if (inorderSize == 1 && postorderSize == 1 && *inorder == *postorder)
    return NewNode(*inorder);

  Tree Root;
  int* PtrRoot;
  int i;

  PtrRoot = postorder + postorderSize - 1;

  for (i = 0; i < inorderSize; ++i)
    if (inorder[i] == *PtrRoot)
      break;

  Root = NewNode(*PtrRoot);

  Root -> left = buildTree(inorder, i, postorder, i);
  Root -> right = buildTree(inorder + i + 1, inorderSize - i - 1, postorder + i, postorderSize - i - 1);

  return Root;
}

int main(int argc, char const *argv[])
{
  Tree T;
  int Postorder[] = {4, 7, 9, 12, 10, 8};
  int Inorder[] = {4, 7, 8, 9, 10, 12};

  // T = CreateTree();

  // PreOrderTraverse(T);
  // printf("\n");

  // InOrderTraverse(T);
  // printf("\n");

  // PostOrderTraverse(T);
  // printf("\n");


  T = buildTree(Inorder, sizeof(Inorder) / sizeof(Inorder[0]), Postorder, sizeof(Postorder) / sizeof(Postorder[0]));

  PreOrderTraverse(T);
  printf("\n");

  InOrderTraverse(T);
  printf("\n");

  PostOrderTraverse(T);
  printf("\n");
  return 0;
}// Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and set.

// get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
// set(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.

#include <stdio.h>
#include <stdlib.h>

#define SIZE 97
typedef struct LruItem* LruNode;
typedef struct LruRecord* LruList;

#define ElementType LruNode
typedef struct HashListNode* HashPosition;

struct HashListNode
{
  ElementType Element;
  HashPosition Next;
};

struct HashTbl
{
  int Capacity;
  HashPosition* HashList;
};

typedef struct HashTbl* HashTable;

struct LruItem 
{
  int Key;
  int Value;
  LruNode Next;
  LruNode Prev;
};

struct LruRecord
{
  LruNode Head;
  LruNode Last;
  int Size;
  int Capacity;
  HashTable HT;
};

HashTable InitHashTable(int Capacity)
{
  HashTable HT;
  int i;

  HT = malloc(sizeof(struct HashTbl));
  HT -> Capacity = Capacity;
  HT -> HashList = malloc(sizeof(HashPosition) * Capacity);

  for (i = 0; i < Capacity; ++i)
  {
    HT -> HashList[i] = malloc(sizeof(struct HashListNode));
    HT -> HashList[i] -> Next = NULL;
  }
    
  return HT;
}

int Hash(int Key, int HashTableSize)
{
  return Key % HashTableSize;
}

HashPosition Find(HashTable HT, int Key)
{
  HashPosition HP, Node;

  HP = HT -> HashList[Hash(Key, HT -> Capacity)];
  Node = HP -> Next;

  while (Node != NULL && Node -> Element -> Key != Key)
    Node = Node -> Next;

  return Node;
}

void Insert(HashTable HT, ElementType Node)
{
  HashPosition P, NewCell;

  P = Find(HT, Node -> Key);
  if (P == NULL)
  {
    NewCell = malloc(sizeof(struct HashListNode));
    NewCell -> Element = Node;
    NewCell -> Next = HT -> HashList[Hash(Node -> Key, HT -> Capacity)] -> Next;
    HT -> HashList[Hash(Node -> Key, HT -> Capacity)] -> Next = NewCell;
  }
}

void Delete(HashTable HT, int Key)
{
  HashPosition HP, Node, PreNode;

  HP = HT -> HashList[Hash(Key, HT -> Capacity)];
  Node = HP -> Next;

  while (Node != NULL && Node -> Element -> Key != Key)
  {
    if (Node -> Element -> Key == Key)
    {
      PreNode -> Next = Node -> Next;
      free(Node);
      return;
    }

    PreNode = Node;
    Node = Node -> Next;
  }
}

void Destroy(HashTable HT)
{
  int i;
  HashPosition HP, Node, PreNode;

  for (i = 0; i < HT -> Capacity; ++i)
  {
    HP = HT -> HashList[i];
    Node = HP -> Next;
    while (Node != NULL)
    {
      PreNode = Node;
      Node = Node -> Next;
      free(PreNode);    
    }
  }

  free(HT -> HashList);
  free(HT);
}

void PrintHT(HashTable HT)
{
  int i;
  HashPosition HP, Node;

  for (i = 0; i < HT -> Capacity; ++i)
  {
    HP = HT -> HashList[i];
    Node = HP -> Next;
    printf("%d: ", i);
    while (Node != NULL)
    {
      printf("(%d, %d) ", Node -> Element -> Key, Node -> Element -> Value);
      Node = Node -> Next;      
    }
    printf("\n");
  }
  printf("\n");
}

LruNode GetNodeOfKey(LruList List, int Key)
{
  LruNode Node;
  HashPosition HP;
  // for (Node = List -> Head -> Next; Node != NULL; Node = Node -> Next)
  //  if (Node -> Key == Key)
  //    return Node;

  HP = Find(List -> HT, Key);
  if (HP == NULL)
    return NULL;

  return HP -> Element;
}

LruNode NewLruNode(int Key, int Value)
{
  LruNode Node;

  Node = malloc(sizeof(struct LruItem));
  Node -> Key = Key;
  Node -> Value = Value;
  Node -> Next = Node -> Prev = NULL;

  return Node;  
}

void RemoveToFirst(LruList List, LruNode NewNode)
{
  if (List -> Last == NewNode)
    List -> Last = NewNode -> Prev;

  if (NewNode -> Prev != NULL)
    NewNode -> Prev -> Next = NewNode -> Next;

  if (NewNode -> Next != NULL)
    NewNode -> Next -> Prev = NewNode -> Prev;

  NewNode -> Next = List -> Head -> Next;
  NewNode -> Prev = List -> Head;

  if (List -> Head -> Next != NULL)
    List -> Head -> Next -> Prev = NewNode;
  
  List -> Head -> Next = NewNode;

  if (List -> Size == 1)
    List -> Last = NewNode;
}

void AddNodeToList(LruList List, int Key, int Value)
{
  LruNode Node, NewNode;

  if (List -> Size == List -> Capacity)
  {
    Node = List -> Last;
    List -> Last = List -> Last -> Prev;
    List -> Last -> Next = NULL;
    --List -> Size;
    Delete(List -> HT, Node -> Key);
    free(Node);
  } 

  ++List -> Size;
  NewNode = NewLruNode(Key, Value);
  Insert(List -> HT, NewNode);
  RemoveToFirst(List, NewNode);
}

void DestroyList(LruList List)
{
  LruNode Node, TmpNode;

  for (Node = List -> Head -> Next; Node != NULL; )
  {
    TmpNode = Node;   
    Node = Node -> Next;
    free(TmpNode);
  }

  free(List -> Head);
  // free(List);
}

void PrintList(LruList List)
{
  LruNode Node;

  for (Node = List -> Head -> Next; Node != NULL; Node = Node -> Next)
    printf("(%d,%d) ", Node -> Key, Node -> Value);

  for (Node = List -> Last; Node != List -> Head; Node = Node -> Prev)
    printf("(%d,%d) ", Node -> Key, Node -> Value);

  printf(", First is (%d,%d), Last is (%d,%d)\n", List -> Head -> Next -> Key, List -> Head -> Next -> Value, List -> Last -> Key, List -> Last -> Value);
}

static LruList TheList;

void lruCacheInit(int capacity) {
  TheList = malloc(sizeof(struct LruRecord));

  TheList -> Size = 0;
  TheList -> Capacity = capacity;
  TheList -> Head = NewLruNode(-1, -1);
  TheList -> Last = NULL;
  TheList -> HT = InitHashTable(SIZE);
}

void lruCacheFree() {
  Destroy(TheList -> HT);
  DestroyList(TheList);
}

int lruCacheGet(int key) {
  LruNode Node;

  Node = GetNodeOfKey(TheList, key);
  if (Node == NULL)
    return -1;

  RemoveToFirst(TheList, Node);
  return Node -> Value;
}
    
void lruCacheSet(int key, int value) {
  LruNode Node, TmpNode;

  Node = GetNodeOfKey(TheList, key);
  if (Node == NULL)
    AddNodeToList(TheList, key, value);
  else
  {
    TmpNode = Node -> Prev;
    Node -> Prev -> Next = Node -> Next;
    if (Node -> Next != NULL)
      Node -> Next -> Prev = TmpNode;
    Node -> Value = value;

    RemoveToFirst(TheList, Node);
  }
}

int main(int argc, char const *argv[])
{
  int Size = 3;
  int Value;

// 2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]
// 3,[set(1,1),set(2,2),set(3,3),set(4,4),get(4),get(3),get(2),get(1),set(5,5),get(1),get(2),get(3),get(4),get(5)]

  lruCacheInit(Size);
  lruCacheSet(1, 1);
  lruCacheSet(2, 2);
  lruCacheSet(3, 3);
  lruCacheSet(4, 4);

  PrintList(TheList);
  Value = lruCacheGet(4);
  printf("%d\n", Value);
  PrintList(TheList);

  Value = lruCacheGet(3);
  printf("%d\n", Value);
  PrintList(TheList);

  Value = lruCacheGet(2);
  printf("%d\n", Value);
  PrintList(TheList);

  Value = lruCacheGet(1);
  printf("%d\n", Value);
  PrintList(TheList);

  lruCacheSet(5, 5);
  PrintList(TheList);

  Value = lruCacheGet(1);
  PrintList(TheList);
  printf("%d\n", Value);
  Value = lruCacheGet(2);
  PrintList(TheList);
  printf("%d\n", Value);
  PrintList(TheList);
  Value = lruCacheGet(3);
  PrintList(TheList);
  printf("%d\n", Value);
  Value = lruCacheGet(4);
  PrintList(TheList);
  printf("%d\n", Value);
  Value = lruCacheGet(5);
  PrintList(TheList);
  printf("%d\n", Value);

  // lruCacheSet(4, 1);
  // Value = lruCacheGet(1);
  // printf("%d\n", Value);

  // Value = lruCacheGet(2);
  // printf("%d\n", Value);

  // lruCacheSet(4, 16);
  // lruCacheSet(5, 25);
  // lruCacheSet(2, 8);
  // lruCacheSet(1, 11);

  // lruCacheInit(Size);
  // lruCacheSet(1, 1);
  // PrintHT(TheList -> HT);
  // lruCacheSet(2, 4);
  // PrintHT(TheList -> HT);
  // lruCacheSet(3, 9);
  // PrintHT(TheList -> HT);
  // lruCacheSet(4, 16);
  // PrintHT(TheList -> HT);
  // lruCacheSet(5, 25);
  // PrintHT(TheList -> HT);
  // lruCacheSet(2, 8);
  // PrintHT(TheList -> HT);
  // lruCacheSet(1, 11);
  // PrintHT(TheList -> HT);

  // Value = lruCacheGet(1);
  // printf("%d\n", Value);
  lruCacheFree();

  return 0;
}/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

#include <stdio.h>
#include <stdlib.h>
#include "lib/tree.h"

typedef struct TreeNode* Tree;
typedef struct TreeNode* Position;

struct TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize) {
  if (preorder == NULL || preorderSize == 0 || inorder == NULL || inorderSize == 0)
    return NULL;

  if (preorderSize == 1 && inorderSize == 1 && *inorder == *preorder)
    return NewNode(*preorder);

  Tree Root;
  int* PtrRoot;
  int i;

  PtrRoot = preorder;

  for (i = 0; i < inorderSize; ++i)
    if (*PtrRoot == inorder[i])
      break;

  Root = NewNode(*PtrRoot);
  Root -> left = buildTree(preorder + 1, i, inorder, i);
  Root -> right = buildTree(preorder + i + 1, preorderSize - i - 1, inorder + i + 1, inorderSize - i - 1);

  return Root;
}

int main(int argc, char const *argv[])
{
  Tree T;
  int Preorder[] = {8, 7, 4, 10, 9, 12};
  int Inorder[] = {4, 7, 8, 9, 10, 12};

  T = buildTree(Preorder, sizeof(Preorder) / sizeof(Preorder[0]), Inorder, sizeof(Inorder) / sizeof(Inorder[0]));

  PreOrderTraverse(T);
  printf("\n");

  InOrderTraverse(T);
  printf("\n");

  PostOrderTraverse(T);
  printf("\n");

  return 0;
}// Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.

// For example,
// Given [3,2,1,5,6,4] and k = 2, return 5.

// Note: 
// You may assume k is always valid, 1 ≤ k ≤ array's length.

#include <stdio.h>
#include <stdlib.h>

int GetMidValueOfIndex(int* Numbers, int Left, int Right)
{
	int Mid;

	Mid = (Left + Right) / 2;

	if (Numbers[Left] > Numbers[Right])
	{
		if (Numbers[Mid] >= Numbers[Left])
			return Left;
		else
		{
			if (Numbers[Mid] >= Numbers[Right])
				return Mid;
			else
				return Right;
		}
	}
	else
	{
		if (Numbers[Mid] >= Numbers[Right])
			return Right;
		else
		{
			if (Numbers[Mid] > Numbers[Left])
				return Mid;
			else
				return Left;
		}
	}
}

void Swap(int* Numbers, int i, int j)
{
	int Temp;

	Temp = Numbers[i];
	Numbers[i] = Numbers[j];
	Numbers[j] = Temp;
}

int Partition(int* Numbers, int Left, int Right)
{
	if (Numbers == NULL || Left > Right)
		return -1;

	if (Left == Right)
		return Left;

	int Pivot;
	int i, j;

	Pivot = GetMidValueOfIndex(Numbers, Left, Right);
	Swap(Numbers, Left, Pivot);

	i = Left + 1;
	j = Right;

	while (i <= j)
	{
		while (Numbers[i] < Numbers[Left]) ++i;
		while (Numbers[j] >= Numbers[Left] && j > Left) --j;

		if (i >= j)
			break;

		Swap(Numbers, i, j);
		++i;
		--j;
	}

	Swap(Numbers, Left, j);

	return j;
}

int findKthLargest(int* nums, int numsSize, int k) {
	int TargetIndex, Index, Left, Right;

	TargetIndex = numsSize - k;
	Left = 0;
	Right = numsSize - 1;
	while (1)
	{
		Index = Partition(nums, Left, Right);
		if (Index > TargetIndex)
			Right = Index - 1;
		else if (Index < TargetIndex)
			Left = Index + 1;
		else
			return nums[Index];
	}
}

void PrintArray(int* Numbers, int Size)
{
	int i;

	for (i = 0; i < Size; ++i)
		printf("%d ", Numbers[i]);
	printf("\n");
}

void QuickSort(int* Numbers, int Left, int Right)
{
	if (Left >= Right)
		return;

	int Pivot;

	Pivot = Partition(Numbers, Left, Right);
	QuickSort(Numbers, Left, Pivot - 1);
	QuickSort(Numbers, Pivot + 1, Right);
}

int main(int argc, char const *argv[])
{
	int i, Size, Index, Value;
	int *Numbers, *DupNumbers;
	int TestNumbers[] = {3,2,3,1,2,4,5,5,6};

	// Size = 16;
	// Numbers = malloc(sizeof(int) * Size);
	// DupNumbers = malloc(sizeof(int) * Size);
	// for (i = 0; i < Size; ++i)
	// {
	// 	Numbers[i] = 3;
	// 	DupNumbers[i] = Numbers[i];
	// }

	// PrintArray(Numbers, Size);
	// Index = Partition(Numbers, 0, Size - 1);
	// printf("%d\n", Index);

	// PrintArray(Numbers, Size);

	// QuickSort(DupNumbers, 0, Size - 1);

	// PrintArray(DupNumbers, Size);

	// for (i = 1; i <= Size; ++i)
	// {
	// 	Value = findKthLargest(Numbers, Size, i);
	// 	printf("%d ", Value);
	// }
	// printf("\n");

	Size = sizeof(TestNumbers) / sizeof(TestNumbers[0]);
	Value = findKthLargest(TestNumbers, Size, 4);
	printf("%d ", Value);
	return 0;
}// Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

#include <stdio.h>

#include "lib/list.h"

typedef struct ListNode* Position;
typedef struct ListNode* List;

struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) {
  List L;
  Position P;

  if (l1 == NULL)
    return l2;

  if (l2 == NULL)
    return l1;

  if (l1 -> val > l2 -> val)
  {
    L = l2;
    l2 = l2 -> next;
  }
  else
  {
    L = l1;
    l1 = l1 -> next;
  }
  
  P = L;

  while (l2 != NULL && l1 != NULL)
  {
    if (l1 -> val < l2 -> val)
    {
      P -> next = l1;
      l1 = l1 -> next;
    }
    else
    {
      P -> next = l2;
      l2 = l2 -> next;
    }

    P = P -> next;
  }

  if (l1 != NULL)
    P -> next = l1;

  if (l2 != NULL)
    P -> next = l2;

  return L;
}

int main(int argc, char const *argv[])
{
  List L1, L2, L;

  L1 = CreateEvenList(10);
  L2 = CreateOddList(10);
  PrintList(L1);
  PrintList(L2);

  L = mergeTwoLists(L1, L2);
  PrintList(L);
  return 0;
}// Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.

// An example is the root-to-leaf path 1->2->3 which represents the number 123.

// Find the total sum of all root-to-leaf numbers.

// For example,

//     1
//    / \
//   2   3
// The root-to-leaf path 1->2 represents the number 12.
// The root-to-leaf path 1->3 represents the number 13.

// Return the sum = 12 + 13 = 25.

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

#include <stdio.h>
#include <stdlib.h>

#include "lib/tree.h"

typedef struct TreeNode* Tree;
typedef struct TreeNode* Position;

void GetSumNumbers(Tree T, int *PathSum, int* TotalSum)
{
	if (T == NULL)
		return;

	if (T -> left == NULL && T -> right == NULL)
	{
		*TotalSum += *PathSum * 10 + T -> val;
		return;
	}

	int StoredSum;

	StoredSum = *PathSum;
	*PathSum = *PathSum * 10 + T -> val;
	GetSumNumbers(T -> left, PathSum, TotalSum);
	GetSumNumbers(T -> right, PathSum, TotalSum);

	*PathSum = StoredSum;
	return;
}

int sumNumbers(struct TreeNode* root) {
    int PathSum, TotalSum;

    PathSum = TotalSum = 0;
    GetSumNumbers(root, &PathSum, &TotalSum);
    return TotalSum;
}

int main(int argc, char const *argv[])
{
	Tree T;

	T = CreateTree();
	PreOrderTraverse(T);
	printf("\n");

	InOrderTraverse(T);
	printf("\n");

	PostOrderTraverse(T);
	printf("\n");
	
	printf("%d\n", sumNumbers(T));
	return 0;
}// Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
#include <stdio.h>
#include <stdlib.h>

#include "lib/list.h"
#include "lib/tree.h"

// struct TreeNode {
//  int val;
//   struct TreeNode *left;
//   struct TreeNode *right;
// };

#define ElementType int
#define SIZE 4

typedef struct ListNode* Position;
typedef struct ListNode* List;
typedef struct TreeNode* Tree;

ElementType* ConvertListToArray(List Head, int* PtrSize)
{
  int i, Capacity;
  List P;
  ElementType* Array;

  Array = malloc(sizeof(ElementType) * Capacity);
  i = 0;
  Capacity = SIZE;
  for (P = Head; P != NULL; P = P -> next)
  {
    if (i >= Capacity)
    {
      Array = realloc(Array, Capacity * 2 * sizeof(ElementType));
      Capacity *= 2;
    }

    Array[i++] = P -> val;
  }
  
  *PtrSize = i;
  return Array;
}

Tree NewTreeNode(int Value)
{
  Tree T;

  T = malloc(sizeof(struct TreeNode));
  T -> left = T -> right = NULL;
  T -> val = Value;

  return T;
}

Tree SortedArrayToBST(ElementType* Array, int Left, int Right)
{
  if (Left > Right)
    return NULL;

  if (Left == Right)
    return NewTreeNode(Array[Left]);

  Tree T;
  int Mid;
  Mid = (Left + Right) / 2;
  T = NewTreeNode(Array[Mid]);
  T -> left = SortedArrayToBST(Array, Left, Mid - 1);
  T -> right = SortedArrayToBST(Array, Mid + 1, Right);

  return T;
}

struct TreeNode* sortedListToBST(struct ListNode* head) {
  int Size;
  ElementType* Array;
  Tree T;

  if (head == NULL)
    return NULL;

  Array = ConvertListToArray(head, &Size);
  T = SortedArrayToBST(Array, 0, Size - 1);
  free(Array);

  return T;
}

int main(int argc, char const *argv[])
{
  List L;
  Tree T;

  L = CreateList(15);
  PrintList(L);

  T = sortedListToBST(L);
  PreOrderTraverse(T);
  printf("\n");
  InOrderTraverse(T);
  printf("\n");
  PostOrderTraverse(T);
  printf("\n");
  return 0;
}// Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.

// The Sudoku board could be partially filled, where empty cells are filled with the character '.'.

// A partially filled sudoku which is valid.

// Note:
// A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int isValidSudoku(char( *board)[9], int boardRowSize, int boardColSize) {
	int i, j, m, n;
	int Hash[10] = {0};

	for (i = 0; i < boardRowSize; ++i)
	{
		memset(Hash, 0, 10 * sizeof(int));
		for (j = 0; j < boardColSize; ++j)
		{
			if (board[i][j] != '.')
			{
				if (Hash[board[i][j] - '0'] != 0)
					return 0;
				else
					++Hash[board[i][j] - '0'];
			}
		}
	}

	for (i = 0; i < boardRowSize; ++i)
	{
		memset(Hash, 0, 10 * sizeof(int));
		for (j = 0; j < boardColSize; ++j)
		{
			if (board[j][i] != '.')
			{
				if (Hash[board[j][i] - '0'] != 0)
					return 0;
				else
					++Hash[board[j][i] - '0'];
			}
		}
	}

	for (i = 0; i < boardRowSize; i += 3)
	{
		for (j = 0; j < boardColSize; j += 3)
		{
			memset(Hash, 0, 10 * sizeof(int));
			for (m = i; m < i + 3; ++m)
			{
				for (n = j; n < j + 3; ++n)
				{
					if (board[m][n] != '.')
					{
						if (Hash[board[m][n] - '0'] != 0)
							return 0;
						else
							++Hash[board[m][n] - '0'];
					} 
				}
			}
		}
	}
	
	return 1;
}

int main(int argc, char const *argv[])
{
	// char board2[3][3] = {
	// 	{'3', '2', '1'},
	// 	{'1', '3', '.'},
	// 	{'2', '1', '2'}
	// };

	char board2[3][3] = {
		{'1', '.', '.'},
		{'.', '.', '.'},
		{'.', '.', '.'}
	};

	char board[][9] = {
	 "....5..1.",
	 ".4.3.....",
	 ".....3..1",
	 "8......2.",
	 "..2.7....",
	 ".15......",
	 ".....2...",
	 ".2.9.....",
	 "..4......"
	};

	// char board[][9] = {
	// 	"..5.....6",
	// 	"....14...",
	// 	".........",
	// 	".....92..",
	// 	"5....2...",
	// 	".......3.",
	// 	"...54....",
	// 	"3.....42.",
	// 	"...27.6.."
	// };

	// char **board;
	// int i, j;

	// board = malloc(sizeof(char*) * 3);
	// for (i = 0; i < 3; ++i)
	// {
	// 	board[i] = malloc(sizeof(char) * 3);
	// 	for (j = 0; j < 3; ++j)
	// 		board[i][j] = board2[i][j];
	// }

	printf("%d\n", isValidSudoku(board, 9, 9));
	return 0;
}